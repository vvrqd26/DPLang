# 语句

<cite>
**本文档引用文件**   
- [ast.rs](file://src/parser/ast.rs#L150-L187)
- [statement.rs](file://src/executor/statement.rs#L7-L67)
- [2.语法参考.md](file://dev_logs/2.语法参考.md)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md)
- [1.核心设计.md](file://dev_logs/1.核心设计.md)
</cite>

## 目录
1. [变量赋值语句](#变量赋值语句)
2. [条件语句](#条件语句)
3. [返回语句](#返回语句)
4. [解构赋值语句](#解构赋值语句)
5. [常见错误示例](#常见错误示例)

## 变量赋值语句

DPLang中的变量赋值语句通过`Stmt::Assignment`枚举变体在抽象语法树（AST）中表示。该设计体现了语言核心的不可变性原则。每个赋值语句包含三个核心字段：`name`（变量名，字符串类型）、`value`（右侧表达式，`Expr`类型）和`is_mut`（布尔标志，指示变量是否可变）。

在数据处理脚本中，所有变量默认为不可变。一旦通过`ma5 = MA(close, 5)`这样的语句赋值，该变量的值在其作用域内无法被修改。任何试图通过`ma5 = ma5 * 2`来“更新”变量的尝试，都会被解释器视为定义一个同名的新变量，这违反了“完全禁止变量遮蔽”的编译期检查规则，从而导致编译错误。这种设计强制开发者使用新的变量名（如`ma5_scaled`），使数据处理流程的每一步都清晰明确，避免了状态的隐式变化。

可变性（`is_mut`）仅在包脚本（package script）中有效，用于定义包级的可变状态（如`mut 调用次数 = 0`），这些状态在解释器的整个生命周期内持续存在，并且只能在包内部被修改。在执行层面，`Executor`通过`execute_stmt`方法处理`Assignment`语句：首先计算右侧表达式的值，然后将其存入当前执行上下文（`context`）的变量存储中。

**语句来源**
- [ast.rs](file://src/parser/ast.rs#L153-L158)
- [statement.rs](file://src/executor/statement.rs#L11-L15)

## 条件语句

DPLang的条件语句由`Stmt::If`枚举变体表示，其结构清晰地反映了控制流。`If`语句包含三个部分：`condition`（一个`Expr`类型的表达式，其结果将被转换为布尔值）、`then_block`（一个`Stmt`语句列表，当条件为真时执行）和`else_block`（一个可选的`Stmt`语句列表，当条件为假时执行）。

`else_block`的`Option<Vec<Stmt>>`类型设计允许`else`分支的省略。如果`else`分支不存在，且条件为假，则控制流将直接跳过整个`if`语句，继续执行后续语句。这种结构支持嵌套的条件逻辑，例如在一个`then_block`中可以包含另一个`if`语句。

在执行时，`Executor`首先计算`condition`表达式的值并将其转换为布尔值。如果结果为`true`，则按顺序执行`then_block`中的每一条语句。如果`then_block`中的任何语句返回了一个值（例如，一个`return`语句），那么`if`语句的执行会立即终止，并将该返回值向上传递。如果条件为`false`且`else_block`存在，则执行`else_block`中的语句，同样遵循返回值的传播规则。

**语句来源**
- [ast.rs](file://src/parser/ast.rs#L166-L171)
- [statement.rs](file://src/executor/statement.rs#L20-L35)

## 返回语句

`Stmt::Return`是DPLang中用于终止脚本执行并返回结果的关键语句。它在AST中被定义为一个简单的枚举变体，封装一个`Expr`类型的表达式。`return`语句的语义是立即停止当前脚本的执行，并将表达式计算出的值作为整个数据处理脚本的输出。

在数据处理脚本中，`return`语句是产生输出的唯一方式。其返回值必须与`-- OUTPUT --`声明中定义的字段数量和类型相匹配，否则会触发编译期的类型检查错误。如果`return`语句返回`null`或在没有`return`语句的情况下脚本执行完毕，则当前数据行将被过滤掉，不会出现在输出流中。

从执行角度看，当`Executor`遇到`Return`语句时，它会计算其内部表达式的值，并返回一个`Some(Value)`结果。这个结果会中断当前语句序列的执行，并被传递给上层的执行逻辑，最终作为该数据行的处理结果。

**语句来源**
- [ast.rs](file://src/parser/ast.rs#L173-L174)
- [statement.rs](file://src/executor/statement.rs#L16-L19)

## 解构赋值语句

解构赋值是DPLang中一种强大的模式匹配机制，由`Stmt::Destructure`枚举变体表示。它允许将一个数组表达式的值拆解并同时赋值给多个变量。该语句包含两个字段：`pattern`（一个`DestructurePattern`枚举的向量，定义了变量名的模式）和`value`（待解构的`Expr`表达式，通常是一个数组）。

`DestructurePattern`枚举定义了三种模式：
- `Identifier(String)`：将数组中的一个元素绑定到指定的变量名。
- `Ignore`：用`_`表示，忽略数组中的某个元素。
- `Spread(String)`：用`...rest`表示，将剩余的所有元素收集到一个新数组中，并赋值给指定的变量。

例如，语句`[a, _, ...rest] = [1, 2, 3, 4, 5]`会将`1`赋给`a`，忽略`2`，并将`[3, 4, 5]`赋给`rest`。执行器通过遍历`pattern`和`value`数组的元素，根据模式类型进行相应的赋值操作。如果数组长度不足，未匹配的变量将不会被创建。

**语句来源**
- [ast.rs](file://src/parser/ast.rs#L160-L164)
- [statement.rs](file://src/executor/statement.rs#L41-L63)

## 常见错误示例

DPLang的编译器在执行前会进行严格的静态检查，以捕获多种常见错误。

**变量遮蔽**：这是最常见的错误之一。由于DPLang完全禁止变量遮蔽，任何试图重新定义已存在变量名的代码都会被拒绝。例如，`ma5 = MA(close, 5)`之后再写`ma5 = ma5 * 2`会触发编译错误。正确的做法是使用新的变量名，如`ma5_scaled = ma5 * 2`。

**非法的可变赋值**：在数据处理脚本中，即使使用`mut`关键字也无法创建可变变量。`mut`关键字仅在包脚本中有效。在数据脚本中使用`mut`或试图修改包级的`mut`变量（如`工具包.调用次数 = 0`）都会导致编译错误。

**其他常见错误**包括：访问未定义的变量、访问私有成员（以`_`开头）、在数据脚本中定义函数、Lambda表达式修改外部变量或参数名遮蔽外部变量等。这些错误都在编译期被检测并报告，确保了代码的健壮性和安全性。

**语句来源**
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L204-L243)
- [1.核心设计.md](file://dev_logs/1.核心设计.md#L233-L264)