# 语言语法参考

<cite>
**本文档引用的文件**   
- [lexer.rs](file://src/lexer.rs)
- [ast.rs](file://src/parser/ast.rs)
- [mod.rs](file://src/parser/mod.rs)
- [2.语法参考.md](file://dev_logs/2.语法参考.md)
- [1.核心设计.md](file://dev_logs/1.核心设计.md)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md)
</cite>

## 更新摘要
**变更内容**   
- 新增对 `elif` 关键字的支持说明
- 新增链式比较表达式的语法和语义说明
- 新增函数定义中默认参数的语法和约束说明
- 更新相关代码示例以反映新特性
- 更新语法解析与AST部分以包含新特性的实现细节

## 目录
1. [词法结构](#词法结构)
2. [表达式](#表达式)
3. [语句](#语句)
4. [特殊声明](#特殊声明)
5. [语法解析与AST](#语法解析与ast)

## 词法结构

DPLang的词法结构定义了源代码的基本组成单元，包括标识符、字面量、运算符和缩进规则。词法分析器（Lexer）负责将源代码分解为一系列的Token，这些Token是后续语法分析的基础。

### 标识符

DPLang支持使用中文字符作为标识符，这使得代码更具可读性和亲和力。标识符的命名规则如下：
- 标识符可以由字母、数字、下划线和中文字符组成。
- 标识符不能以数字开头。
- 标识符区分大小写。

```rust
// 示例
涨幅 = 100
昨日收盘 = close[-1]
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L619-L629)

### 字面量

DPLang支持多种字面量，包括数字、字符串和布尔值。

- **数字字面量**：支持整数、浮点数和科学计数法。
- **字符串字面量**：支持单引号和双引号包围的字符串，支持转义字符。
- **布尔字面量**：`true` 和 `false`。
- **空值**：`null`。

```rust
// 示例
价格 = 100.12
描述 = "这是一个测试"
有效 = true
空值 = null
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L333-L412)

### 运算符

DPLang支持多种运算符，包括算术、比较、逻辑、赋值和箭头运算符。

- **算术运算符**：`+`、`-`、`*`、`/`、`%`、`^`。
- **比较运算符**：`>`、`<`、`>=`、`<=`、`==`、`!=`。
- **逻辑运算符**：`and`、`or`、`not`。
- **赋值运算符**：`=`。
- **箭头运算符**：`->`，用于Lambda表达式。
- **管道运算符**：`|>`，用于链式调用。

```rust
// 示例
总和 = a + b
是否大于 = a > b
是否相等 = a == b
条件 = a and b
lambda = x -> x * 2
结果 = 数据 |> 过滤 |> 映射 |> 聚合
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L31-L55)

### 缩进规则

DPLang使用缩进来表示代码块的层次结构，类似于Python。缩进必须使用空格，且每个缩进级别为4个空格。

```dplang
if 条件:
    # 缩进的代码块
    执行操作
else:
    # 另一个缩进的代码块
    执行其他操作
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L273-L323)

## 表达式

DPLang的表达式包括算术、比较、逻辑、三元条件和管道表达式。这些表达式是构建复杂逻辑的基础。

### 算术表达式

算术表达式支持基本的数学运算，如加、减、乘、除、取模和幂运算。

```dplang
# 示例
总和 = a + b
差值 = a - b
乘积 = a * b
商 = a / b
余数 = a % b
幂 = a ^ b
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L87-L96)

### 比较表达式

比较表达式用于比较两个值的大小关系，返回布尔值。

```dplang
# 示例
是否大于 = a > b
是否小于 = a < b
是否大于等于 = a >= b
是否小于等于 = a <= b
是否相等 = a == b
是否不相等 = a != b
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L98-L104)

### 链式比较表达式

DPLang支持链式比较表达式，允许将多个比较操作连接在一起。链式比较在语义上等价于使用逻辑与（`and`）连接的多个比较表达式。

**语法规则**：
- 支持连续的比较操作，如 `a < b < c`。
- 解析为 `(a < b) and (b < c)` 的形式。
- 中间操作数在逻辑表达式中被复用。

```dplang
# 示例
# 以下两种写法等价
0 < x < 10
(0 < x) and (x < 10)

# 多重链式比较
1 <= a < b <= 10
(1 <= a) and (a < b) and (b <= 10)
```

**语义解析**：
链式比较表达式在语法分析阶段被转换为等价的逻辑与表达式。例如，`0 < x < 10` 被解析为 `Expr::Binary` 节点，其操作符为 `BinaryOp::And`，左右操作数分别为 `(0 < x)` 和 `(x < 10)` 的二元比较表达式。

**Section sources**
- [mod.rs](file://src/parser/mod.rs#L592-L642)
- [mod.rs](file://src/parser/mod.rs#L1101-L1117)

### 逻辑表达式

逻辑表达式用于组合多个布尔值，支持逻辑与、逻辑或和逻辑非。

```dplang
# 示例
条件1 = a and b
条件2 = a or b
条件3 = not a
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L106-L109)

### 三元条件表达式

三元条件表达式提供了一种简洁的条件判断方式，格式为 `condition ? then_expr : else_expr`。

```dplang
# 示例
结果 = a > b ? "大于" : "小于等于"
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L39-L44)

### 管道表达式

管道表达式允许将一个表达式的结果作为下一个表达式的输入，形成链式调用，提高代码的可读性。

```dplang
# 示例
结果 = 数据 |> 过滤(条件) |> 映射(函数) |> 聚合(操作)
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L80-L84)

## 语句

DPLang的语句包括变量赋值、条件分支、函数定义和返回语句。这些语句构成了程序的主体逻辑。

### 变量赋值

变量赋值语句用于将一个值赋给一个变量。DPLang中的变量默认是不可变的，如果需要可变变量，需要使用 `mut` 关键字。

```dplang
# 示例
ma5 = MA(close, 5)
mut 计数 = 0
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L153-L158)

### if/elif/else条件分支

if/elif/else语句用于多分支条件判断。`elif` 关键字提供了更简洁的多条件分支语法，避免了深层嵌套。

**语法规则**：
- `if` 条件后跟冒号 `:` 和缩进块。
- 零个或多个 `elif` 子句，每个后跟条件、冒号和缩进块。
- 零个或一个 `else` 子句，后跟冒号和缩进块。
- 所有分支块必须使用4个空格进行缩进。

```dplang
# 示例
if ma5 > ma10:
    return [code, 股票名, close, ma5, ma10]
elif ma5 == ma10:
    return [code, 股票名, close, "持平"]
else:
    return null
```

**语义解析**：
`elif` 分支在内部被转换为嵌套的 `if-else` 结构。例如，上述代码在AST中被表示为 `if` 语句的 `else` 块中包含另一个 `if` 语句。

**Section sources**
- [lexer.rs](file://src/lexer.rs#L11)
- [mod.rs](file://src/parser/mod.rs#L393-L481)

### 函数定义

函数定义语句用于定义一个函数，函数可以有参数和返回值。函数定义使用冒号 `:` 标记。

```dplang
# 示例
计算涨跌幅(open:number, close:number) -> number:
    涨幅 = (close - open) / open * 100
    return 涨幅
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L189-L196)

### 函数参数默认值

DPLang支持在函数定义中为参数指定默认值。这使得函数调用更加灵活，允许省略具有默认值的参数。

**语法规则**：
- 默认值通过 `=` 操作符指定，位于参数名和类型标注之后。
- 一旦某个参数有默认值，其后的所有参数都必须有默认值。
- 默认值必须是编译时常量表达式。

```dplang
# 示例
# 定义带有默认参数的函数
计算移动平均(数据, 周期=5, 类型="SMA") -> array:
    if 类型 == "SMA":
        return SMA(数据, 周期)
    elif 类型 == "EMA":
        return EMA(数据, 周期)
    else:
        ERROR("不支持的移动平均类型")

# 调用示例
ma1 = 计算移动平均(close)          # 使用默认周期5和类型"SMA"
ma2 = 计算移动平均(close, 10)      # 使用周期10，类型默认"SMA"
ma3 = 计算移动平均(close, 20, "EMA") # 指定所有参数
```

**语义约束**：
- 默认参数必须位于参数列表的末尾。
- 语法分析器会检查默认参数的连续性，如果非默认参数出现在默认参数之后，将产生语法错误。

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L200-L203)
- [mod.rs](file://src/parser/mod.rs#L265-L339)

### return语句

return语句用于从函数中返回一个值。如果函数没有返回值，可以省略return语句。

```dplang
# 示例
return [code, 涨幅, 是否涨停]
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L173-L174)

## 特殊声明

DPLang支持几种特殊声明，用于定义输入、输出、导入、包、错误处理和精度设置。

### INPUT和OUTPUT

INPUT和OUTPUT声明用于定义数据处理脚本的输入和输出参数。

```dplang
# 示例
-- INPUT code:string, 股票名:string, open:number, close:number, high:number, low:number, volume:number --
-- OUTPUT code:string, 股票名:string, close:number, ma5:number, ma10:number --
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L19-L21)
- [mod.rs](file://src/parser/mod.rs#L95-L108)

### IMPORT

IMPORT声明用于导入其他包中的函数和变量。

```dplang
# 示例
-- IMPORT math, utils --
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L21-L22)
- [mod.rs](file://src/parser/mod.rs#L95-L103)

### PACKAGE

PACKAGE声明用于定义一个包脚本，包脚本在解释器启动时执行一次，用于定义函数和包级变量。

```dplang
# 示例
package 工具包
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L12)
- [mod.rs](file://src/parser/mod.rs#L40-L43)

### ERROR

ERROR声明用于定义错误处理块，当脚本执行过程中发生异常时，会跳转到ERROR块执行错误处理逻辑。

```dplang
# 示例
-- ERROR --
if _error.type == "ZeroDivision":
    return [code, 0, "除零错误"]
else:
    exit("严重错误: " + _error.message)
-- ERROR_END --
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L22-L23)
- [mod.rs](file://src/parser/mod.rs#L109-L111)

### PRECISION

PRECISION声明用于设置计算的精度，特别是在金融计算中，可以指定小数位数。

```dplang
# 示例
-- PRECISION 6 --
```

**Section sources**
- [lexer.rs](file://src/lexer.rs#L24)
- [mod.rs](file://src/parser/mod.rs#L112-L121)

## 语法解析与AST

DPLang的语法解析器（Parser）负责将词法分析器生成的Token序列转换为抽象语法树（AST）。AST是程序的内部表示，用于后续的语义分析和代码生成。

### AST节点

AST节点包括表达式节点、语句节点、函数定义节点等。每个节点都有特定的结构和属性。

```rust
// 表达式节点
#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Number(f64),
    String(String),
    Bool(bool),
    Null,
    Identifier(String),
    Array(Vec<Expr>),
    Binary {
        left: Box<Expr>,
        op: BinaryOp,
        right: Box<Expr>,
    },
    Unary {
        op: UnaryOp,
        operand: Box<Expr>,
    },
    Ternary {
        condition: Box<Expr>,
        then_expr: Box<Expr>,
        else_expr: Box<Expr>,
    },
    Call {
        callee: String,
        args: Vec<Expr>,
    },
    MemberAccess {
        object: String,
        member: String,
    },
    Index {
        base: Box<Expr>,
        index: Box<Expr>,
    },
    Slice {
        base: Box<Expr>,
        start: Option<Box<Expr>>,
        end: Option<Box<Expr>>,
    },
    Spread(Box<Expr>),
    Lambda {
        params: Vec<String>,
        body: Box<Expr>,
    },
    Pipeline {
        value: Box<Expr>,
        stages: Vec<Expr>,
    },
}

// 语句节点
#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    Assignment {
        name: String,
        value: Expr,
        is_mut: bool,
    },
    Destructure {
        pattern: Vec<DestructurePattern>,
        value: Expr,
    },
    If {
        condition: Expr,
        then_block: Vec<Stmt>,
        else_block: Option<Vec<Stmt>>,
    },
    Return(Expr),
    Expression(Expr),
}

// 函数参数
#[derive(Debug, Clone, PartialEq)]
pub struct Parameter {
    pub name: String,
    pub type_annotation: Option<TypeAnnotation>,
    pub default_value: Option<Expr>,  // 新增：默认参数值
}
```

**Section sources**
- [ast.rs](file://src/parser/ast.rs#L7-L84)
- [ast.rs](file://src/parser/ast.rs#L200-L203)

### 语法分析

语法分析器使用递归下降的方法解析Token序列，生成AST。解析过程包括表达式解析、语句解析和函数定义解析。

```rust
// 语法分析器
pub struct Parser {
    tokens: Vec<Token>,
    current: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self;
    pub fn parse(&mut self) -> Result<Script, ParseError>;
    
    // 脚本解析
    fn parse_package_script(&mut self) -> Result<Script, ParseError>;
    fn parse_data_script(&mut self) -> Result<Script, ParseError>;
    
    // 声明解析
    fn parse_input_output(&mut self) -> Result<Vec<Parameter>, ParseError>;
    fn parse_error_block(&mut self) -> Result<Vec<Stmt>, ParseError>;
    
    // 语句解析
    fn parse_statement(&mut self) -> Result<Stmt, ParseError>;
    fn parse_assignment(&mut self) -> Result<Stmt, ParseError>;
    fn parse_if_statement(&mut self) -> Result<Stmt, ParseError>;
    fn parse_return_statement(&mut self) -> Result<Stmt, ParseError>;
    
    // 表达式解析（优先级递归下降）
    fn parse_expression(&mut self) -> Result<Expr, ParseError>;
    fn parse_pipeline(&mut self) -> Result<Expr, ParseError>;      // |> 最低优先级
    fn parse_ternary(&mut self) -> Result<Expr, ParseError>;       // ? :
    fn parse_or(&mut self) -> Result<Expr, ParseError>;            // or
    fn parse_and(&mut self) -> Result<Expr, ParseError>;           // and
    fn parse_comparison(&mut self) -> Result<Expr, ParseError>;    // > < >= <= == !=
    fn parse_addition(&mut self) -> Result<Expr, ParseError>;      // + -
    fn parse_multiplication(&mut self) -> Result<Expr, ParseError>;// * / %
    fn parse_power(&mut self) -> Result<Expr, ParseError>;         // ^
    fn parse_unary(&mut self) -> Result<Expr, ParseError>;         // - not
    fn parse_call(&mut self) -> Result<Expr, ParseError>;          // 函数调用
    fn parse_primary(&mut self) -> Result<Expr, ParseError>;       // 基础表达式
    
    // Lambda 解析
    fn parse_lambda(&mut self) -> Result<Expr, ParseError>;
    
    // 函数定义解析
    fn parse_function_def(&mut self) -> Result<FunctionDef, ParseError>;
    
    // 辅助方法
    fn match_token(&mut self, types: &[TokenType]) -> bool;
    fn consume(&mut self, token_type: TokenType, msg: &str) -> Result<Token, ParseError>;
    fn peek(&self) -> &Token;
    fn is_at_end(&self) -> bool;
}
```

**Section sources**
- [mod.rs](file://src/parser/mod.rs#L24-L28)
- [mod.rs](file://src/parser/mod.rs#L360-L421)