# 避免变量遮蔽

<cite>
**本文档引用文件**   
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md)
- [2.语法参考.md](file://dev_logs/2.语法参考.md)
- [1.核心设计.md](file://dev_logs/1.核心设计.md)
- [7.解释器实现设计.md](file://dev_logs/7.解释器实现设计.md)
</cite>

## 目录
1. [引言](#引言)
2. [变量遮蔽规则](#变量遮蔽规则)
3. [错误示例](#错误示例)
4. [正确做法](#正确做法)
5. [Lambda表达式中的遮蔽](#lambda表达式中的遮蔽)
6. [推荐实践](#推荐实践)
7. [底层实现原理](#底层实现原理)

## 引言

DPLang语言设计中，变量遮蔽（Variable Shadowing）被完全禁止。这一设计决策旨在提升代码的可读性、可维护性和执行效率。通过禁止变量重新赋值和Lambda参数遮蔽，DPLang强制开发者采用清晰的数据处理流程，避免因变量状态变化导致的逻辑错误。本文档结合`dev_logs/6.最佳实践.md`中的具体示例，详细说明如何避免变量遮蔽，帮助开发者编写符合语言规范的健壮代码。

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L96-L129)

## 变量遮蔽规则

DPLang语言中，变量遮蔽被严格禁止，这包括两个核心规则：

1.  **禁止变量重新赋值**：一旦一个变量被声明，其名称在当前作用域内不能再被用于新的赋值。这并非简单的“不可变”限制，而是从作用域层面彻底禁止同名变量的重复定义。
2.  **禁止Lambda参数遮蔽**：在Lambda表达式中，其参数名不能与外部作用域中已存在的变量名相同，以防止意外的遮蔽。

这些规则在编译期由语义分析器（Semantic Analyzer）进行强制检查，任何违反规则的代码都将导致编译错误。

**Section sources**
- [1.核心设计.md](file://dev_logs/1.核心设计.md#L64-L78)
- [7.解释器实现设计.md](file://dev_logs/7.解释器实现设计.md#L519-L527)

## 错误示例

以下代码片段展示了违反DPLang变量遮蔽规则的典型错误。

### 试图修改已定义的变量

在DPLang中，`ma5 = ma5 * 2` 这样的语句是非法的。它试图用一个新值重新赋值给已存在的变量`ma5`，这在语法上被视为“变量遮蔽”，而非简单的值更新。

```DPLang
# ❌ 错误：想要修改变量
ma5 = MA(close, 5)
ma5 = ma5 * 2  # 编译错误
```

此代码会触发编译器报错，因为语义分析器在遇到第二个`ma5`的赋值时，会检测到`ma5`已在当前作用域中定义，从而抛出`VariableShadowing`错误。

### Lambda参数名与外部变量冲突

在使用高阶函数（如`map`、`filter`）时，如果Lambda表达式的参数名与外部变量同名，也会导致编译错误。

```DPLang
# ❌ 错误：Lambda 参数遮蔽
x = 10
map(array, x -> x * 2)  # 编译错误
```

在此例中，外部变量`x`与Lambda的参数`x`同名，这会造成作用域混乱，因此被语言规则明确禁止。

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L98-L108)
- [2.语法参考.md](file://dev_logs/2.语法参考.md#L34-L35)

## 正确做法

遵循DPLang的规则，开发者应采用以下方式来处理需要“更新”变量值的场景。

### 使用新变量名

最直接的解决方案是为计算结果创建一个具有描述性新名称的变量。

```DPLang
# ✅ 正确：使用新变量名
ma5 = MA(close, 5)
ma5_scaled = ma5 * 2
```

通过使用`ma5_scaled`这样的新名称，代码清晰地表达了“对`ma5`进行缩放操作”的意图，避免了遮蔽问题，同时增强了代码的可读性。

### 使用更具描述性的名称

对于更复杂的场景，可以使用更具业务含义的名称来区分原始值和变换后的值。

```DPLang
# ✅ 正确：使用有意义的名称
原始ma5 = MA(close, 5)
调整后ma5 = 原始ma5 * 调整系数
```

这种方法不仅解决了技术问题，还使代码的业务逻辑更加清晰。

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L110-L119)

## Lambda表达式中的遮蔽

在编写Lambda表达式时，必须确保其参数名不会与外部作用域的任何变量名冲突。

### 正确的参数命名

应选择与外部变量不同的、有意义的参数名。

```DPLang
# ✅ 正确：Lambda 使用不同参数名
x = 10
map(array, item -> item * x)
```

在此例中，Lambda使用`item`作为参数名，而外部变量为`x`，两者名称不同，因此是合法的。Lambda可以安全地读取外部变量`x`的值，但不能修改它。

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L120-L123)
- [2.语法参考.md](file://dev_logs/2.语法参考.md#L310-L316)

## 推荐实践

除了避免遮蔽，DPLang还提供了更高级的编程范式来简化数据处理流程。

### 使用管道操作符避免中间变量

DPLang的管道操作符`|>`允许将一系列操作链式连接，从而避免创建不必要的中间变量，使代码更加简洁和函数式。

```DPLang
# ✅ 正确：使用管道避免中间变量
result = array
    |> map(item -> item * 2)
    |> filter(item -> item > 10)
```

这种写法不仅避免了`ma5_scaled`这类中间变量的命名，还清晰地表达了“先映射，后过滤”的数据处理流程，是DPLang中推荐的最佳实践。

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L124-L129)
- [2.语法参考.md](file://dev_logs/2.语法参考.md#L374-L387)

## 底层实现原理

变量遮蔽规则的强制执行依赖于DPLang解释器的语义分析阶段。

### 作用域栈与遮蔽检测

解释器使用一个`ScopeStack`（作用域栈）来管理变量的声明和查找。当分析器遇到一个变量赋值语句时，它会调用`check_no_shadowing`函数。

```rust
fn check_no_shadowing(&mut self, name: &str, line: usize) -> Result<(), SemanticError> {
    // 检查当前作用域和所有父作用域
    if self.scope_stack.lookup(name).is_some() {
        return Err(SemanticError::VariableShadowing {
            name: name.to_string(),
            line,
        });
    }
    Ok(())
}
```

该函数会检查`name`是否已在当前作用域或任何父作用域中存在。如果存在，则立即返回一个`VariableShadowing`错误，阻止代码编译。

### Lambda的特殊检查

对于Lambda表达式，解释器有专门的`check_lambda_constraints`函数，其中第一条规则就是“参数名不能遮蔽外部变量”，确保了Lambda作用域的清晰和安全。

**Diagram sources **
- [7.解释器实现设计.md](file://dev_logs/7.解释器实现设计.md#L519-L527)
- [7.解释器实现设计.md](file://dev_logs/7.解释器实现设计.md#L531-L537)

**Section sources**
- [7.解释器实现设计.md](file://dev_logs/7.解释器实现设计.md#L487-L556)
- [src/semantic.rs](file://src/semantic.rs#L249-L263)