# 性能优化

<cite>
**Referenced Files in This Document**  
- [dev_logs/6.最佳实践.md](file://dev_logs/6.最佳实践.md)
- [src/executor/builtin.rs](file://src/executor/builtin.rs)
- [src/executor/tests.rs](file://src/executor/tests.rs)
</cite>

## 目录
1. [避免重复计算](#避免重复计算)
2. [优先使用安全函数](#优先使用安全函数)
3. [管道操作优化](#管道操作优化)

## 避免重复计算

在DPLang中，时间序列数据的引用具有语义上的高效性，不会产生数据复制开销。因此，应避免对同一时间序列数据进行多次重复计算，而是通过变量缓存中间结果以提高执行效率。

例如，在计算历史数据的最大值、最小值和平均值时，应先将`close[-20:0]`赋值给一个变量，然后复用该变量进行后续计算。这种做法不仅提升了性能，还增强了代码的可读性和维护性。

```DPLang
# ✅ 好：时间序列只计算一次（引用语义）
历史数据 = close[-20:0]
最大值 = max(...历史数据)
最小值 = min(...历史数据)
平均值 = mean(历史数据)

# ❌ 差：重复计算（低效）
最大值 = max(...close[-20:0])
最小值 = min(...close[-20:0])
平均值 = mean(close[-20:0])
```

通过将时间序列切片结果缓存到变量中，可以显著减少解释器对底层数据结构的访问次数，从而降低整体执行时间。此优化策略尤其适用于涉及多个聚合函数或复杂逻辑处理的场景。

**Section sources**
- [dev_logs/6.最佳实践.md](file://dev_logs/6.最佳实践.md#L295-L310)

## 优先使用安全函数

DPLang提供了多种内置的安全函数（如`safe_div`和`safe_get`），用于处理常见的异常情况，例如除零错误或数组越界访问。相较于手动编写条件检查语句，直接调用这些安全函数更为简洁且高效。

### safe_div 函数
`safe_div(a, b, default=0.0)` 函数用于执行安全的除法运算。当除数为零时，函数返回指定的默认值，避免了运行时错误。

```rust
/// safe_div 函数 - 安全除法（避免除零错误）
/// safe_div(a, b, default=0.0)
fn builtin_safe_div(&self, args: &[Value]) -> Result<Value, RuntimeError> {
    if args.len() < 2 || args.len() > 3 {
        return Err(RuntimeError::type_error("safe_div 需要 2-3 个参数"));
    }
    
    let a = args[0].to_number()?;
    let b = args[1].to_number()?;
    let default = if args.len() == 3 {
        args[2].to_number()?
    } else {
        0.0
    };
    
    if b == 0.0 {
        Ok(Value::Number(default))
    } else {
        Ok(Value::Number(a / b))
    }
}
```

### safe_get 函数
`safe_get(array, index, default=null)` 函数用于安全地访问数组元素。当索引超出范围时，函数返回指定的默认值。

```rust
/// safe_get 函数 - 安全数组访问（避免越界）
/// safe_get(array, index, default=null)
fn builtin_safe_get(&self, args: &[Value]) -> Result<Value, RuntimeError> {
    if args.len() < 2 || args.len() > 3 {
        return Err(RuntimeError::type_error("safe_get 需要 2-3 个参数"));
    }
    
    let arr = match &args[0] {
        Value::Array(a) => a,
        _ => return Err(RuntimeError::type_error("safe_get 的第一个参数必须是数组")),
    };
    
    let index = args[1].to_number()? as i64;
    let default = if args.len() == 3 {
        args[2].clone()
    } else {
        Value::Null
    };
    
    // 处理负数索引
    let actual_index = if index < 0 {
        let positive_index = arr.len() as i64 + index;
        if positive_index < 0 {
            return Ok(default);
        }
        positive_index as usize
    } else {
        index as usize
    };
    
    if actual_index >= arr.len() {
        Ok(default)
    } else {
        Ok(arr[actual_index].clone())
    }
}
```

使用安全函数代替冗长的手动检查，不仅可以减少代码量，还能避免因遗漏边界条件而导致的潜在错误。

```DPLang
# ✅ 好：使用安全函数
涨幅 = safe_div(close - open, open, default=0.0)
昨收 = safe_get(历史数据, -1, default=close)

# ❌ 差：手动检查（冗长且可能遗漏）
if open != 0:
    涨幅 = (close - open) / open
else:
    涨幅 = 0.0

if len(历史数据) > 0:
    昨收 = 历史数据[-1]
else:
    昨收 = close
```

**Section sources**
- [dev_logs/6.最佳实践.md](file://dev_logs/6.最佳实践.md#L311-L329)
- [src/executor/builtin.rs](file://src/executor/builtin.rs#L498-L554)

## 管道操作优化

在使用管道操作符（`|>`）进行数据处理时，应遵循“先过滤再映射”的原则，以减少后续复杂计算的数据量。这一策略能够有效提升脚本的整体执行效率，特别是在处理大规模数据集时效果尤为明显。

### 优化前：先映射后过滤
```DPLang
# ❌ 差：先映射大量数据，再过滤
result = large_array
    |> map(x -> 复杂计算(x))   # 对所有数据计算
    |> filter(x -> x > 阈值)  # 然后过滤
```
在此模式下，即使大部分数据最终会被过滤掉，`复杂计算(x)` 仍会对整个数据集中的每个元素执行，造成不必要的计算资源浪费。

### 优化后：先过滤再映射
```DPLang
# ✅ 好：先过滤减少数据量，再映射
result = large_array
    |> filter(x -> x > 阈值)  # 先过滤
    |> map(x -> 复杂计算(x))   # 对少量数据进行复杂计算
```
通过将`filter`操作置于`map`之前，可以在执行昂贵的映射操作前剔除不符合条件的数据，从而大幅减少需要处理的数据量。

此外，DPLang的管道操作支持链式调用，使得数据处理流程更加清晰易懂。结合使用`filter`、`map`和`reduce`等高阶函数，可以构建出高效且可读性强的数据处理管道。

```DPLang
# ✅ 好：清晰的数据处理流程
成本 = 100
高收益阈值 = 50

result = prices
    |> filter(p -> p > 成本)          # 筛选
    |> map(p -> p - 成本)             # 转换
    |> filter(profit -> profit > 高收益阈值)  # 再筛选
    |> reduce((sum, p) -> sum + p)    # 聚合
```

**Section sources**
- [dev_logs/6.最佳实践.md](file://dev_logs/6.最佳实践.md#L330-L343)
- [dev_logs/6.最佳实践.md](file://dev_logs/6.最佳实践.md#L517-L532)