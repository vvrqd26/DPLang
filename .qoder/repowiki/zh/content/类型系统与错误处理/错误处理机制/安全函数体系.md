# 安全函数体系

<cite>
**本文档引用文件**   
- [builtin.rs](file://src/executor/builtin.rs)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md)
- [5.完整示例.md](file://dev_logs/5.完整示例.md)
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md)
</cite>

## 目录
1. [引言](#引言)
2. [安全函数设计哲学](#安全函数设计哲学)
3. [核心安全函数详解](#核心安全函数详解)
4. [金融数据分析应用示例](#金融数据分析应用示例)
5. [安全函数与异常处理的协同](#安全函数与异常处理的协同)
6. [性能与可读性权衡](#性能与可读性权衡)
7. [最佳实践总结](#最佳实践总结)

## 引言
DPLang语言提供了一套完善的内置安全函数体系，旨在通过防御性编程范式预防可预见的运行时错误。这些安全函数通过前置错误处理机制，将潜在的除零、数组越界、类型转换失败等异常情况转化为可控的程序流，从而构建更加健壮和可靠的数据处理管道。本文档将深入解析`safe_div`、`safe_get`、`safe_number`和`safe_decimal`等核心安全函数的实现原理与应用场景。

**Section sources**
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L171-L197)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L154-L175)

## 安全函数设计哲学
DPLang的安全函数体系遵循“错误处理前置”的设计哲学，与`ERROR`块处理意外异常的机制形成互补。其核心思想是将可预见的、逻辑上的边界条件错误（如除零、越界）在函数调用点直接处理，而不是让程序抛出异常并跳转到全局错误处理块。这种方式使得错误处理逻辑与业务逻辑紧密结合，提高了代码的内聚性和可预测性。

这种设计将错误分为两类：
1.  **可预见的逻辑错误**：使用安全函数处理，如`safe_div`处理除零。
2.  **意外的运行时异常**：使用`ERROR`块处理，如数据源突然中断。

**Section sources**
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L154-L203)
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L312-L372)

## 核心安全函数详解

### safe_div函数：防御除零错误
`safe_div`函数用于执行安全的除法运算，有效防止除零错误。该函数接受两个必需参数和一个可选的默认值参数。

**函数签名**：
```DPLang
safe_div(a, b)                      # 除零返回null
safe_div(a, b, default=0.0)         # 除零返回指定的默认值
```

**实现机制**：
在`builtin.rs`中，`builtin_safe_div`函数首先验证参数数量，然后将参数转换为数值。如果除数`b`为0.0，则返回用户指定的默认值（若未指定则默认为0.0）；否则执行正常的除法运算并返回结果。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L498-L517)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L173-L174)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L159-L161)

### safe_get函数：避免数组越界
`safe_get`函数用于安全地访问数组元素，避免因索引越界而导致的程序崩溃。

**函数签名**：
```DPLang
safe_get(array, index)              # 越界返回null
safe_get(array, index, default=0)   # 越界返回指定的默认值
```

**实现机制**：
`builtin_safe_get`函数首先检查第一个参数是否为数组。它支持负数索引（如`-1`表示倒数第一个元素）。函数会计算实际的访问索引，并判断其是否在数组的有效范围内。如果越界，则返回默认值（若未指定则为`null`）；否则返回对应索引的元素。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L520-L554)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L177-L178)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L163-L165)

### safe_number和safe_decimal函数：确保安全的类型转换
`safe_number`和`safe_decimal`函数用于将任意值安全地转换为数值类型，避免因无效字符串转换而导致的错误。

**函数签名**：
```DPLang
safe_number(value)                  # 转换失败返回null
safe_number(value, default=0)       # 转换失败返回指定的默认值
safe_decimal(value)                 # 转换失败返回null
safe_decimal(value, default=0)      # 转换失败返回指定的默认值
```

**实现机制**：
`builtin_safe_number`函数尝试将输入值转换为`f64`。如果转换成功，则返回该数值；如果失败（如将非数字字符串转换为数字），则返回用户指定的默认值。`safe_decimal`函数原理类似，但目标类型为高精度的`Decimal`。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L556-L573)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L180-L185)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L167-L169)

## 金融数据分析应用示例
结合`dev_logs/4.内置函数参考.md`中的示例，可以展示安全函数在金融数据分析中的实际应用。

### 计算涨幅
计算股票涨幅时，开盘价可能为0，直接相除会引发除零错误。使用`safe_div`可以优雅地处理此情况：
```DPLang
涨幅 = safe_div(close - open, open, default=0.0)
```
此代码确保即使`open`为0，程序也不会崩溃，而是将`涨幅`设为0.0。

### 访问历史数据
在计算移动平均线时，需要访问历史收盘价。使用`safe_get`可以安全地获取历史数据，避免因数据不足导致的越界访问：
```DPLang
昨收 = safe_get(历史数据, -1, default=close)
```
如果`历史数据`数组为空或没有前一个元素，函数将返回当前价格`close`作为默认值。

**Section sources**
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L188-L190)
- [5.完整示例.md](file://dev_logs/5.完整示例.md#L50-L54)

## 安全函数与异常处理的协同
安全函数与`ERROR`块是互补而非替代的关系。最佳实践是结合使用两者：
-   **使用安全函数**：处理可预见的、逻辑上的边界情况，如除零、越界、空值等。
-   **使用ERROR块**：处理意外的、无法在调用点预见的异常，如数据源连接失败、内存不足等。

例如，在一个数据处理脚本中，可以同时使用：
```DPLang
-- ERROR --
# 处理意外的严重错误
exit("发生严重错误: " + _error.message)
-- ERROR_END --

# 可预见的错误使用安全函数
涨幅 = safe_div(close - open, open, default=0.0)
昨日价 = safe_get(历史数据, -1, default=close)
```

**Section sources**
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L176-L203)
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L373-L390)

## 性能与可读性权衡
与传统的`try-catch`异常捕获机制相比，DPLang的安全函数在性能和可读性上具有优势。

**性能**：安全函数的错误检查是内联的，避免了异常抛出和栈展开的开销，因此性能更高。

**可读性**：安全函数将错误处理逻辑直接嵌入到表达式中，使代码意图更加清晰。相比之下，`try-catch`块会将错误处理逻辑与主业务逻辑分离，可能导致代码分散。

**对比示例**：
```DPLang
# 使用安全函数（推荐） - 简洁、高效
涨幅 = safe_div(close - open, open, default=0.0)

# 手动检查（不推荐） - 冗长、易遗漏
if open != 0:
    涨幅 = (close - open) / open
else:
    涨幅 = 0.0
```

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L312-L329)

## 最佳实践总结
1.  **优先使用安全函数**：对于所有可预见的边界条件，优先使用`safe_div`、`safe_get`等安全函数。
2.  **合理设置默认值**：根据业务逻辑选择合适的默认值，如`0.0`、`null`或当前值。
3.  **结合ERROR块使用**：用安全函数处理逻辑错误，用`ERROR`块处理系统级异常。
4.  **避免冗余检查**：不要在使用安全函数后再进行额外的条件判断，这违背了其设计初衷。

**Section sources**
- [6.最佳实践.md](file://dev_logs/6.最佳实践.md#L312-L390)
- [3.类型系统和错误处理.md](file://dev_logs/3.类型系统和错误处理.md#L176-L203)