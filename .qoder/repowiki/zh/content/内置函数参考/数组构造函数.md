# 数组构造函数

<cite>
**Referenced Files in This Document**  
- [builtin.rs](file://src/executor/builtin.rs#L294-L370)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L63-L77)
- [5.完整示例.md](file://dev_logs/5.完整示例.md#L56-L332)
</cite>

## 目录
1. [简介](#简介)
2. [Range函数详解](#range函数详解)
3. [Array函数详解](#array函数详解)
4. [参数约束与边界处理](#参数约束与边界处理)
5. [性能特征](#性能特征)
6. [金融分析中的典型应用](#金融分析中的典型应用)
7. [结论](#结论)

## 简介
本文档详细介绍了DPLang中的两个核心数组构造函数：`Range`和`Array`。这两个函数为数据处理和金融分析提供了强大的数组生成能力。`Range`函数用于生成等差数列序列，支持正负步长；`Array`函数则提供了两种数组创建模式：固定值填充和Lambda表达式生成器。这些函数在金融数据分析中具有广泛的应用，如生成时间索引、初始化指标数组等场景。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L294-L370)

## Range函数详解
`Range`函数用于生成指定范围内的等差数列序列。该函数支持三个参数：起始值、结束值和可选的步长。当步长未指定时，默认为1.0。

函数的基本语法为`Range(start, end, step)`，其中`start`为起始值，`end`为结束值，`step`为步长。函数会根据步长的正负自动判断递增或递减序列。对于正步长，生成从`start`到`end`（包含）的递增序列；对于负步长，则生成从`start`到`end`（包含）的递减序列。

例如，`Range(1, 10)`生成[1,2,3,4,5,6,7,8,9,10]，`Range(0, 10, 2)`生成[0,2,4,6,8,10]，而`Range(10, 1, -1)`则生成[10,9,8,7,6,5,4,3,2,1]的倒序序列。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L294-L335)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L70-L72)

## Array函数详解
`Array`函数提供了两种模式来创建固定长度的数组。第一种模式是固定值填充，即创建指定长度的数组并用给定的默认值填充所有元素。第二种模式是使用Lambda表达式作为生成器，根据索引动态计算每个元素的值。

函数的基本语法为`Array(size, value_or_lambda)`，其中`size`指定数组长度，第二个参数可以是固定值或Lambda表达式。当使用固定值时，如`Array(10, 0)`，会创建一个长度为10、所有元素均为0的数组。当使用Lambda表达式时，如`Array(10, i -> i * 2)`，会创建一个长度为10的数组，其中每个元素的值由Lambda表达式根据索引`i`计算得出，结果为[0,2,4,6,8,10,12,14,16,18]。

Lambda模式特别适用于需要根据位置或索引生成特定值的场景，如生成斐波那契数列、指数增长序列等复杂模式。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L334-L370)
- [4.内置函数参考.md](file://dev_logs/4.内置函数参考.md#L75-L77)

## 参数约束与边界处理
`Range`和`Array`函数都实施了严格的参数约束和边界处理机制，以确保函数的健壮性和安全性。

对于`Range`函数，参数约束包括：必须提供2-3个参数，步长不能为零。如果步长为零，函数会抛出"Range 的步长不能为 0"的类型错误。边界处理方面，函数会根据步长的正负自动调整比较条件，确保生成正确的序列。对于正步长，使用`current <= end`作为循环条件；对于负步长，则使用`current >= end`。

对于`Array`函数，参数约束包括：必须提供恰好2个参数，当使用Lambda模式时，Lambda表达式必须有且仅有一个参数。边界处理方面，函数将数组大小转换为`usize`类型，确保非负性。当使用Lambda模式时，函数会遍历从0到`size-1`的所有索引，为每个位置执行Lambda表达式。

这些约束和处理机制确保了函数在各种输入条件下都能正确运行，避免了潜在的运行时错误。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L294-L370)

## 性能特征
`Range`和`Array`函数在设计上注重性能效率，采用了直接的循环和向量操作，避免了不必要的计算开销。

`Range`函数的时间复杂度为O(n)，其中n是生成序列的长度。函数使用简单的while循环和数值累加，每步操作都是常数时间。内存方面，函数预先分配结果向量，避免了动态扩容的开销。

`Array`函数的性能特征取决于使用模式。在固定值填充模式下，性能最优，时间复杂度为O(n)，利用Rust的`vec![value; size]`语法实现高效的内存填充。在Lambda生成器模式下，时间复杂度仍为O(n)，但每步需要执行Lambda表达式的求值，引入了额外的函数调用开销。尽管如此，这种模式提供了极大的灵活性，允许生成复杂的数值模式。

两个函数都返回`Value::Array`类型的值，与其他数组函数无缝集成，支持链式调用和高阶函数操作，进一步提升了数据处理的效率。

**Section sources**
- [builtin.rs](file://src/executor/builtin.rs#L294-L370)

## 金融分析中的典型应用
`Range`和`Array`函数在金融分析中有多种典型应用，特别是在处理时间序列数据和构建分析模型时。

### 生成时间索引
在金融数据分析中，经常需要生成时间索引用于历史数据访问。`Range`函数可以轻松生成连续的索引序列，用于`map`和`reduce`等高阶函数中。例如，在计算连续上涨天数时，可以使用`Range(1, 20)`生成过去20天的索引，然后通过`map`函数比较相邻日期的价格变化。

```dplang
连续上涨天数 = Range(1, 20)
    |> map(i -> close[-i] < close[-(i-1)] ? 1 : 0)
    |> reduce((count, is_up) -> is_up ? count + 1 : 0)
```

### 初始化指标数组
`Array`函数的固定值填充模式非常适合初始化指标数组。例如，在实现移动平均线交叉策略时，可以使用`Array`函数初始化权重数组，然后结合`map`和`sum`函数计算综合评分。

```dplang
条件列表 = [ma5 > ma10, 涨幅 > 0, pe > 0 and pe < 20, volume > mean(volume[-5:])]
分数权重 = Array(4, 0)
分数权重[0] = 30
分数权重[1] = 20
分数权重[2] = 30
分数权重[3] = 20
分数 = sum(map(Range(0, 4), i -> 条件列表[i] ? 分数权重[i] : 0))
```

### 动态窗口计算
`Array`函数的Lambda模式特别适用于动态窗口计算。例如，在回测系统中，可以使用`Range(0, _index)`生成从开始到当前的所有历史索引，然后通过`reduce`函数模拟交易过程，计算累计收益率和胜率。

```dplang
交易结果 = reduce(
    Range(0, _index),
    {持仓: false, 买入价: 0, 收益: []},
    (state, i) -> {
        当前信号 = 历史信号[i]
        当前价格 = 历史价格[i]
        if 当前信号 == "买入" and not state.持仓:
            return {持仓: true, 买入价: 当前价格, 收益: state.收益}
        if 当前信号 == "卖出" and state.持仓:
            收益率 = (当前价格 - state.买入价) / state.买入价
            return {持仓: false, 买入价: 0, 收益: [...state.收益, 收益率]}
        return state
    }
)
```

这些应用示例展示了`Range`和`Array`函数在金融分析中的强大功能和灵活性，它们与其他内置函数结合使用，可以构建复杂而高效的分析模型。

**Section sources**
- [5.完整示例.md](file://dev_logs/5.完整示例.md#L56-L332)

## 结论
`Range`和`Array`函数作为DPLang的核心数组构造函数，为数据处理和金融分析提供了基础而强大的功能。`Range`函数通过生成等差数列序列，支持了各种基于索引的数据访问和计算需求；`Array`函数则通过固定值填充和Lambda生成器两种模式，提供了灵活的数组创建能力。这两个函数都实施了严格的参数约束和边界处理，确保了运行时的安全性。在性能方面，它们采用了高效的实现方式，适合处理大规模金融数据。通过与高阶函数和其他内置函数的组合使用，`Range`和`Array`函数能够支持从简单指标计算到复杂策略回测的各种金融分析场景，是构建高效数据分析流水线的重要工具。