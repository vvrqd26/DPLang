# DPLang v1.3 - 完整示例

## 示例1：简单过滤

```DPLang
-- INPUT code:string, name:string, close:number --
-- OUTPUT code:string, name:string, close:number --

-- ERROR --
return null  # 任何错误都过滤该行
-- ERROR_END --

# 只保留收盘价大于10的股票
return close > 10 ? _args : null
```

## 示例2：计算技术指标

```DPLang
-- INPUT code:string, name:string, close:number --
-- OUTPUT code:string, name:string, close:number, ma5:number, ma10:number, signal:string --

-- ERROR --
return null
-- ERROR_END --

ma5 = MA(close, 5)
ma10 = MA(close, 10)
signal = ma5 > ma10 ? "金叉" : "死叉"

return [code, name, close, ma5, ma10, signal]
```

## 示例3:使用历史数据和 Lambda

```DPLang
-- INPUT code:string, close:number, volume:number --
-- OUTPUT code:string, 涨幅:number, 是否新高:bool, 量比:number, 连续上涨天数:number --

-- ERROR --
return [code, 0, false, 0, 0]
-- ERROR_END --

# 获取历史数据(下标索引,引用语义,无复制开销)
昨收 = close[-1]
历史20天 = close[-20:0]
历史5日成交量 = volume[-5:]

# 计算指标
涨幅 = safe_div(close - 昨收, 昨收, default=0.0) * 100
最高价 = max(...历史20天)
是否新高 = close >= 最高价
平均成交量 = mean(历史5日成交量)
量比 = safe_div(volume, 平均成交量, default=1.0)

# 使用 Lambda 计算连续上涨天数
涨跌列表 = map(Range(1, 20), i -> close[-i] < close[-(i-1)])
连续上涨天数 = reduce(涨跌列表, (count, is_up) -> is_up ? count + 1 : count)

return [code, 涨幅, 是否新高, 量比, 连续上涨天数]
```

## 示例4：复杂条件筛选和评分

```DPLang
-- INPUT code:string, close:number, volume:number, pe:number --
-- OUTPUT code:string, 评级:string, 分数:number --

-- ERROR --
if _error.type == "NullReference":
    return null  # 数据不全，过滤
exit("错误: " + _error.message)
-- ERROR_END --

# 计算基础指标
ma5 = MA(close, 5)
ma10 = MA(close, 10)
昨收 = close[-1]
涨幅 = safe_div(close - 昨收, 昨收, default=0.0) * 100

# 使用数组和高阶函数计算评分
条件列表 = [
    ma5 > ma10,
    涨幅 > 0,
    pe > 0 and pe < 20,
    volume > mean(volume[-5:])
]

分数权重 = [30, 20, 30, 20]
分数 = sum(map(Range(0, 3), i -> 条件列表[i] ? 分数权重[i] : 0))

# 评级
评级 = 分数 >= 80 ? "A" : (分数 >= 60 ? "B" : (分数 >= 40 ? "C" : "D"))

# 只返回评级B以上的股票
return 分数 >= 60 ? [code, 评级, 分数] : null
```

## 示例5：自定义包

```DPLang
# 文件：my_indicators.dpl
package 指标库

# ========== 包级常量 ==========
默认短期 = 5
默认长期 = 10
默认信号周期 = 20

# 私有配置
_调试模式 = false
_最大缓存 = 1000

# ========== 包级状态 ==========
mut 调用统计 = 0
mut 错误计数 = 0
mut _缓存 = []

# ========== 公开函数 ==========

# 双均线信号
双均线信号(close:number, 短期:number, 长期:number) -> string:
    ma_short = MA(close, 短期)
    ma_long = MA(close, 长期)
    
    昨日短均 = ma_short[-1]
    昨日长均 = ma_long[-1]
    
    调用统计 = 调用统计 + 1
    
    # 金叉
    if 昨日短均 <= 昨日长均 and ma_short > ma_long:
        return "金叉"
    
    # 死叉
    if 昨日短均 >= 昨日长均 and ma_short < ma_long:
        return "死叉"
    
    return "持有"

# 便捷函数（使用默认参数）
快速双均线(close:number) -> string:
    return 双均线信号(close, 默认短期, 默认长期)

# 综合强度(价格+成交量)
计算强度(close:number, volume:number) -> number:
    昨收 = close[-1]
    涨幅 = safe_div(close - 昨收, 昨收, default=0.0)
    
    历史成交量 = volume[-5:]
    量比 = safe_div(volume, mean(历史成交量), default=1.0)
    
    强度 = 涨幅 * 量比
    
    return _标准化强度(强度)

# 突破信号
突破信号(close:number, 周期:number) -> bool:
    历史数据 = close[-周期:0]
    最高价 = max(...历史数据)
    
    # 今日收盘突破历史最高
    return close > 最高价

# ========== 私有函数 ==========

_标准化强度(强度:number) -> number:
    # 将强度映射到0-100
    标准化值 = (强度 + 1) * 50
    标准化值 = max(0, min(100, 标准化值))
    return 标准化值

_清理缓存():
    _缓存 = []
    return null

_记录错误(错误信息:string):
    错误计数 = 错误计数 + 1
    if _调试模式:
        # 这里可以记录日志
        return null
    return null
```

### 使用自定义包

```DPLang
-- INPUT code:string, close:number, volume:number --
-- OUTPUT code:string, 信号:string, 强度:number, 是否突破:bool --

-- ERROR --
return null
-- ERROR_END --

# 使用包函数
信号 = 指标库.快速双均线(close)
强度 = 指标库.计算强度(close, volume)
是否突破 = 指标库.突破信号(close, 20)

# 访问包常量
短期周期 = 指标库.默认短期

# 读取调用统计
调用次数 = 指标库.调用统计

# 只返回有信号的股票
return 信号 != "持有" ? [code, 信号, 强度, 是否突破] : null
```

## 示例6：高精度金融计算

```DPLang
-- INPUT code:string, price:decimal, shares:number --
-- OUTPUT code:string, 总金额:decimal, 手续费:decimal, 实付:decimal --
-- PRECISION decimal --  # 使用高精度模式

-- ERROR --
return [code, decimal(0), decimal(0), decimal(0)]
-- ERROR_END --

# decimal类型保证精度
手续费率 = decimal(0.0003)  # 万三手续费
印花税率 = decimal(0.001)   # 千一印花税

# 计算
总金额 = price * shares
手续费 = 总金额 * 手续费率
印花税 = 总金额 * 印花税率
实付 = 总金额 + 手续费 + 印花税

# 四舍五入到分
实付 = round(实付, 2)

return [code, 总金额, 手续费, 实付]
```

## 示例7：使用管道和 Lambda

```DPLang
-- INPUT code:string, prices:array --
-- OUTPUT code:string, 高收益股票数量:number, 总收益:number --

-- ERROR --
return [code, 0, 0]
-- ERROR_END --

成本 = 100
高收益阈值 = 50

# 管道式数据处理
高收益价格 = prices
    |> filter(p -> p > 成本)          # 筛选高于成本的价格
    |> map(p -> p - 成本)             # 计算利润
    |> filter(profit -> profit > 高收益阈值)  # 筛选高收益

高收益股票数量 = len(高收益价格)
总收益 = reduce(高收益价格, (sum, p) -> sum + p)

return [code, 高收益股票数量, 总收益]
```

## 示例8：多指标综合策略

```DPLang
-- INPUT code:string, open:number, high:number, low:number, close:number, volume:number --
-- OUTPUT code:string, 信号:string, 强度:number, 原因:string --

-- ERROR --
if _error.type == "NullReference":
    return null
exit("错误: " + _error.message)
-- ERROR_END --

# 计算技术指标
ma5 = MA(close, 5)
ma10 = MA(close, 10)
ma20 = MA(close, 20)
[dif, dea, macd] = MACD(close, 12, 26, 9)
rsi = RSI(close, 14)
[上轨, 中轨, 下轨] = BOLL(close, 20, 2)

# 量能指标
vol_ma5 = VOLUME_MA(volume, 5)
量比 = safe_div(volume, vol_ma5, default=1.0)

# 趋势判断
趋势向上 = ma5 > ma10 and ma10 > ma20
macd金叉 = dif > dea and dif[-1] <= dea[-1]
超卖 = rsi < 30
突破中轨 = close > 中轨 and close[-1] <= 中轨[-1]
放量 = 量比 > 1.5

# 综合信号评分
信号条件 = [趋势向上, macd金叉, 超卖, 突破中轨, 放量]
信号权重 = [30, 25, 20, 15, 10]

强度 = sum(map(Range(0, 4), i -> 信号条件[i] ? 信号权重[i] : 0))

# 生成原因描述
原因列表 = filter(
    ["趋势向上", "MACD金叉", "RSI超卖", "突破布林中轨", "放量"],
    (reason, i) -> 信号条件[i]
)
原因 = reduce(原因列表, "", (result, r) -> result == "" ? r : result + "+" + r)

# 信号判断
信号 = 强度 >= 70 ? "强买入" : (强度 >= 50 ? "买入" : (强度 >= 30 ? "观望" : "卖出"))

# 只返回有明确信号的
return 强度 >= 30 ? [code, 信号, 强度, 原因] : null
```

## 示例9：回测数据处理

```DPLang
-- INPUT code:string, date:string, close:number, signal:string --
-- OUTPUT code:string, 总收益率:number, 胜率:number, 交易次数:number --

-- ERROR --
return [code, 0, 0, 0]
-- ERROR_END --

# 模拟交易
持仓 = false
买入价 = 0
交易记录 = []

历史信号 = signal[0:0]
历史价格 = close[0:0]

# 使用高阶函数处理交易
交易结果 = reduce(
    Range(0, _index),
    {持仓: false, 买入价: 0, 收益: []},
    (state, i) -> {
        当前信号 = 历史信号[i]
        当前价格 = 历史价格[i]
        
        # 买入信号
        if 当前信号 == "买入" and not state.持仓:
            return {持仓: true, 买入价: 当前价格, 收益: state.收益}
        
        # 卖出信号
        if 当前信号 == "卖出" and state.持仓:
            收益率 = (当前价格 - state.买入价) / state.买入价
            return {持仓: false, 买入价: 0, 收益: [...state.收益, 收益率]}
        
        return state
    }
)

# 统计
交易次数 = len(交易结果.收益)
总收益率 = reduce(交易结果.收益, (sum, r) -> sum + r)
盈利次数 = count(filter(交易结果.收益, r -> r > 0))
胜率 = safe_div(盈利次数, 交易次数, default=0) * 100

return [code, 总收益率, 胜率, 交易次数]
```

## 示例10：动态窗口计算

```DPLang
-- INPUT code:string, close:number, volatility:number --
-- OUTPUT code:string, 动态均线:number, 波动率等级:string --

-- ERROR --
return [code, close, "未知"]
-- ERROR_END --

# 根据波动率动态调整窗口大小
基础周期 = 10
最小周期 = 5
最大周期 = 30

# 波动率越高，周期越短（更灵敏）
动态周期 = volatility > 0.05 ? 最小周期 : (
    volatility < 0.02 ? 最大周期 : 基础周期
)

动态均线 = MA(close, 动态周期)

# 使用管道计算历史波动率等级
历史波动 = volatility[-20:0]
波动率分位 = len(filter(历史波动, v -> v < volatility)) / len(历史波动)

波动率等级 = 波动率分位 > 0.8 ? "极高" : (
    波动率分位 > 0.6 ? "高" : (
        波动率分位 > 0.4 ? "中" : (
            波动率分位 > 0.2 ? "低" : "极低"
        )
    )
)

return [code, 动态均线, 波动率等级]
```
