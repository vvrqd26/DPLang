# DPLang v1.3 - 语法参考

## 基本语法

脚本以行为单位，每个行为一个完整的语句，无需分号

```DPLang
# 这是注释
# datafeed 输入的数据行是 [code, 股票名, open, close, high, low, volume]

-- INPUT code:string, 股票名:string, open:number, close:number, high:number, low:number, volume:number --
-- OUTPUT code:string, 股票名:string, close:number, ma5:number, ma10:number --

# 变量赋值（不可变，无需关键字）
ma5 = MA(close, 5)
ma10 = MA(close, 10)

# 使用 return 关键字明确返回
return [code, 股票名, close, ma5, ma10]
```

## 数据处理脚本

数据处理脚本在每行数据上执行，所有变量都是局部变量，执行完毕后立即释放

```DPLang
-- INPUT code:string, close:number --
-- OUTPUT code:string, signal:string --

# 局部变量（执行完自动释放）
ma5 = MA(close, 5)
ma10 = MA(close, 10)

# ❌ 错误：变量遮蔽
# ma5 = ma5 * 2  # 编译错误：ma5已定义

# ✅ 正确：使用新变量名
ma5_adjusted = ma5 * 2

signal = ma5 > ma10 ? "金叉" : "死叉"

return [code, signal]
```

## 包脚本

包脚本在解释器启动时执行一次，用于定义函数和包级变量

```DPLang
package 工具包

# ========== 包级变量 ==========

# 公开常量（不可变）
涨停阈值 = 0.1
短期周期 = 5
长期周期 = 10

# 私有常量（包外不可访问）
_内部配置 = 100
_调试模式 = false

# 公开可变状态（需要 mut 关键字）
mut 调用次数 = 0
mut 错误计数 = 0

# 私有可变状态
mut _缓存数据 = []
mut _最后更新时间 = 0

# ========== 函数定义 ==========

# 公开函数（通过冒号识别函数定义）
计算涨跌幅(open:number, close:number) -> number:
    涨幅 = (close - open) / open * 100
    
    # 修改包级可变状态（只能在包内修改）
    调用次数 = 调用次数 + 1
    
    return 涨幅
    # 注意：涨幅变量在return后立即销毁

# 私有函数（包外不可访问）
_内部辅助计算(x:number) -> number:
    temp = x * 2
    result = temp + _内部配置
    return result
    # temp和result在return后销毁

# 不带类型签名的函数（类型推断）
判断涨停(涨幅):
    return 涨幅 >= 涨停阈值
```

### 在数据脚本中使用包

```DPLang
-- INPUT code:string, open:number, close:number --
-- OUTPUT code:string, 涨幅:number, 是否涨停:bool --

# ✅ 调用公开函数
涨幅 = 工具包.计算涨跌幅(open, close)

# ✅ 访问公开常量
阈值 = 工具包.涨停阈值

# ✅ 读取公开可变状态
次数 = 工具包.调用次数

# ❌ 错误：访问私有成员
# config = 工具包._内部配置  # 编译错误：私有变量

# ❌ 错误：修改包级状态（只能在包内修改）
# 工具包.调用次数 = 0  # 编译错误：只有包内可修改mut变量

是否涨停 = 工具包.判断涨停(涨幅)

return [code, 涨幅, 是否涨停]
```

## 条件分支

```DPLang
# if-else 语句（else可选）
ma5 = MA(close, 5)
ma10 = MA(close, 10)

if ma5 > ma10:
    return [code, 股票名, close, ma5, ma10]
else:
    return null

# 省略else，默认返回null
if ma5 > ma10:
    return [code, 股票名, close, ma5, ma10]

# 三元表达式
信号 = ma5 > ma10 ? "买入" : "观望"
result = ma5 > ma10 ? [code, close] : null
return result

# 嵌套条件
if close > offset(close, -1):
    if volume > offset(volume, -1):
        return [code, "放量上涨"]
    else:
        return [code, "缩量上涨"]
else:
    return null
```

## 数据引用(时间序列)

使用**下标索引**方式访问历史和未来数据,采用**引用语义**避免数据复制:

```DPLang
# 获取单个历史值(负数下标)
昨天收盘 = close[-1]          # 上一行的close值
前5天收盘 = close[-5]         # 第5行之前的close值
# 如果历史不足,返回null

# 获取单个未来值(正数下标,不推荐)
明天收盘 = close[1]           # 下一行的close值(回测场景可用)

# 获取历史切片(不包含当前行)
过去5天 = close[-5:]          # 返回数组[最近5个历史值],不足用null填充
过去10到5天 = close[-10:-5]  # 返回数组[第10天到第5天的值]

# 获取历史切片(包含当前行)
过去5天含今天 = close[-5:0]   # 返回数组[最近5个+当前],共6个元素

# 获取未来切片(不推荐)
未来5天 = close[1:6]          # 返回数组[未来5个值]

# 获取窗口数据
窗口数据 = close[-2:2]        # 前2天+当前+后2天,返回数组[5个元素]

# 从数据流开始到当前行
全部历史 = close[0:0]         # 0到当前行的所有数据

# 实际应用示例
昨收 = close[-1]
今涨幅 = (close - 昨收) / 昨收 * 100

历史5天 = close[-5:0]
5日均价 = mean(历史5天)
是否新高 = close >= max(...历史5天)
```

**语法规则**:
- `var[index]` - 单值访问: 负数表示历史,正数表示未来,0表示当前
- `var[start:end]` - 切片访问: 返回数组,不包含end位置
- `var[-n:]` - 最近n个历史值
- `var[-n:0]` - 最近n个历史值+当前值
- 历史不足时自动填充null

**性能说明**:
- 下标访问使用**引用语义**,不复制数据
- 切片返回的是原始数据的视图引用
- 避免大量历史数据的内存复制开销

## 向量运算

```DPLang
# 向量与向量运算（逐元素）
[1, 2, 3] + [4, 5, 6]           # [5, 7, 9]
[1, 2, 3] > [4, 5, 6]           # [false, false, false]
[1, 2, 3] * [2, 3, 4]           # [2, 6, 12]

# 向量与标量运算（广播）
[1, 2, 3] + 1                   # [2, 3, 4]
[1, 2, 3] > 1                   # [false, true, true]
[1, 2, 3] * 2                   # [2, 4, 6]

# 逻辑运算（非零即true）
[1, 2, 3] and [4, 5, 6]         # [true, true, true]
[1, 0, 3] or [0, 5, 0]          # [true, true, true]
not [0, 1, 0]                   # [true, false, true]

# 实际应用
历史收盘 = past(close, 20, true)
历史涨幅 = (历史收盘 - offset(历史收盘, -1)) / offset(历史收盘, -1)
上涨天数 = sum(历史涨幅 > 0)
```

## 解构语法

```DPLang
# 数组解构
[a, b, c] = [1, 2, 3]

# 函数返回值解构
[dif, dea, macd] = MACD(close, 12, 26, 9)

# 展开运算符（用于返回时保留原有字段）
新字段 = 100
return [..._args, 新字段]    # 保留所有输入字段，添加新字段

# 部分解构
[code, name, ...rest] = _args
return [code, name, 新字段]

# 忽略部分字段
[code, _, close] = _args     # _ 表示忽略该字段
```

## 内置变量

```DPLang
# 数据上下文
_args          # 当前输入数据行的所有字段（只读数组）
_args_names    # 输入字段名数组
_index         # 当前数据行索引（从0开始）
_total         # 总数据行数

# 错误上下文（仅在 ERROR 块中可用）
_error         # 错误对象
_error.type    # 错误类型字符串
_error.message # 错误描述信息
_error.line    # 发生错误的行号

# 示例
当前是第几行 = _index + 1
是否最后一行 = _index == _total - 1
输入字段数 = len(_args_names)
```

## Lambda 表达式

Lambda 表达式用于高阶函数，仅支持**单个表达式**，可以读取外部变量但**禁止修改**。

### 基本语法

```DPLang
# 单参数
result = map([1,2,3], x -> x * 2)  # [2,4,6]

# 多参数
indexed = map([10,20,30], (value, index) -> value + index)  # [10,21,32]

# 访问外部变量（只读）
阈值 = 100
倍数 = 2
成本 = 50

# ✅ 允许：读取外部变量
高于阈值 = filter(prices, p -> p > 阈值)
翻倍 = map(values, v -> v * 倍数)

# ✅ 允许：复杂表达式
利润 = map(prices, p -> (p - 成本) * 倍数 > 阈值 ? p - 成本 : 0)
```

### 限制和错误

```DPLang
# ❌ 禁止：修改外部变量
计数 = 0
map(array, x -> 计数 = 计数 + 1)  # 编译错误：禁止修改外部变量

# ❌ 禁止：多行代码块
result = map(prices, p -> {  # 编译错误：仅支持单表达式
    temp = p * 2
    return temp + 1
})

# ❌ 禁止：Lambda 内定义变量
map(array, x -> { y = x * 2; y + 1 })  # 编译错误

# ❌ 禁止：参数名遮蔽外部变量
x = 10
map(array, x -> x * 2)  # 编译错误：Lambda 参数 x 遮蔽外部变量

# ✅ 正确：使用不同参数名
x = 10
map(array, item -> item * x)
```

### 作用域规则

- ✅ 可以读取外部变量（词法作用域）
- ❌ 禁止修改外部变量（保持纯函数）
- ❌ 禁止在 Lambda 内定义新变量
- ❌ 仅支持单个表达式，不支持代码块
- ⚠️ Lambda 参数名不能与外部变量同名（避免遮蔽）

## 高阶函数

### map - 转换每个元素

```DPLang
# 基本用法
doubled = map([1,2,3], x -> x * 2)  # [2,4,6]

# 带 index
阈值 = 10
indexed = map([5,15,25], (val, i) -> val > 阈值 ? i : -1)  # [-1,1,2]

# 使用外部变量
倍数 = 2
scaled = map(prices, p -> p * 倍数)
```

### filter - 筛选元素

```DPLang
# 基本用法
filtered = filter([1,2,3,4,5], x -> x > 2)  # [3,4,5]

# 使用外部变量
阈值 = 100
高价股票 = filter(prices, p -> p > 阈值)

# 复杂条件
成本 = 50
利润率 = 0.2
好股票 = filter(stocks, s -> s.price > 成本 and (s.price - 成本) / 成本 > 利润率)
```

### reduce - 聚合

```DPLang
# 基本用法
sum = reduce([1,2,3,4], (acc, x) -> acc + x)  # 10

# 带初始值
product = reduce([1,2,3,4], 1, (acc, x) -> acc * x)  # 24

# 复杂聚合
历史涨幅 = map(past(close, 20, true), c -> ...)
最大连续上涨 = reduce(历史涨幅, (max_count, is_up) -> is_up ? max_count + 1 : 0)
```

### 管道运算符 |>

链式调用，提高可读性

```DPLang
# 基本用法
成本 = 100
阈值 = 50

result = prices
    |> filter(p -> p > 成本)          # 筛选高于成本的
    |> map(p -> p - 成本)             # 计算利润
    |> filter(profit -> profit > 阈值) # 筛选高利润
    |> reduce((a,b) -> a + b)         # 求和

# 实际应用
历史20天 = past(close, 20, true)

连续上涨天数 = Range(1, 20)
    |> map(i -> offset(close, -i) < offset(close, -(i-1)) ? 1 : 0)
    |> reduce((count, is_up) -> is_up ? count + 1 : 0)

# 数据清洗和转换
清洗后数据 = 原始数据
    |> filter(x -> x != null)         # 过滤空值
    |> map(x -> x * 调整系数)         # 调整
    |> filter(x -> x > 0)             # 保留正值
```

## 关键字

```DPLang
# 核心关键字（不可用作变量名）
return          # 返回语句
if, else        # 条件分支
package         # 包声明
mut             # 可变状态声明（仅包级变量）
null            # 空值
true, false     # 布尔值

# 运算符
+, -, *, /, %, ^              # 算术运算
>, <, >=, <=, ==, !=          # 比较运算
and, or, not                  # 逻辑运算
? :                           # 三元运算
...                           # 展开运算符
->                            # Lambda 箭头
|>                            # 管道运算符

# 保留字（未来可能使用）
for, while, break, continue   # 保留但不实现（使用高阶函数代替）
import, export                # 保留用于模块系统
let, const, var, fn           # 保留（避免与其他语言混淆）
```
