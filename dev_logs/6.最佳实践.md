# DPLang v1.3 - 最佳实践

## 命名规范

### 包级常量

使用描述性名称，清晰表达用途

```DPLang
# ✅ 好的命名
涨停阈值 = 0.1
默认周期 = 20
最大持仓数 = 10

# ❌ 不好的命名
a = 0.1
num = 20
max = 10
```

### 局部变量

简洁明确，体现业务含义

```DPLang
# ✅ 好的命名
ma5 = MA(close, 5)
涨幅 = (close - open) / open
是否新高 = close >= max(...历史数据)

# ❌ 不好的命名
temp1 = MA(close, 5)
result = (close - open) / open
flag = close >= max(...历史数据)
```

### 私有成员

使用 `_` 前缀

```DPLang
package 工具包

# ✅ 私有成员命名
_内部配置 = 100
_调试模式 = false

_辅助计算(x):
    return x * 2

# ✅ 公开成员命名
默认参数 = 10
计算涨跌幅(open, close):
    return (close - open) / open
```

### 函数命名

动词开头或描述性名称

```DPLang
# ✅ 好的函数名
计算涨跌幅(open, close):
    return (close - open) / open

判断涨停(涨幅):
    return 涨幅 >= 涨停阈值

筛选强势股(stocks, 阈值):
    return filter(stocks, s -> s.强度 > 阈值)

# ❌ 不好的函数名
处理(open, close):  # 太模糊
f1(涨幅):           # 无意义
filter_data(stocks, 阈值):  # 不使用中文
```

### Lambda 参数

简洁单字母或描述性名称

```DPLang
# ✅ 简单逻辑用单字母
map(array, x -> x * 2)
filter(prices, p -> p > 100)
reduce(values, (a, b) -> a + b)

# ✅ 复杂逻辑用描述性名称
filter(stocks, stock -> stock.收益率 > 0.1 and stock.风险度 < 0.5)
map(交易记录, 交易 -> 交易.价格 * 交易.数量)

# ✅ 带索引用描述性名称
map(数据, (值, 索引) -> 索引 > 0 ? 值 - offset(值, -1) : 0)
```

## 避免变量遮蔽

### 错误示例

```DPLang
# ❌ 错误：想要修改变量
ma5 = MA(close, 5)
ma5 = ma5 * 2  # 编译错误

# ❌ 错误：Lambda 参数遮蔽
x = 10
map(array, x -> x * 2)  # 编译错误
```

### 正确示例

```DPLang
# ✅ 正确：使用新变量名
ma5 = MA(close, 5)
ma5_scaled = ma5 * 2

# ✅ 正确：使用有意义的名称
原始ma5 = MA(close, 5)
调整后ma5 = 原始ma5 * 调整系数

# ✅ 正确：Lambda 使用不同参数名
x = 10
map(array, item -> item * x)

# ✅ 正确：使用管道避免中间变量
result = array
    |> map(item -> item * 2)
    |> filter(item -> item > 10)
```

## 合理使用包级可变状态

### 推荐用途

```DPLang
package 统计包

# ✅ 合理：统计信息
mut 调用次数 = 0
mut 错误计数 = 0

# ✅ 合理：缓存
mut _缓存 = []
mut _最后更新时间 = 0

# ✅ 合理：配置状态（包内修改）
mut 调试级别 = 0

更新调试级别(level:number):
    调试级别 = level
    return null
```

### 谨慎使用

```DPLang
# ⚠️ 慎用：业务状态
# 包脚本顺序执行且仅执行一次，所以是安全的
mut 累计收益 = 0.0
mut 交易次数 = 0

记录交易(收益:number):
    累计收益 = 累计收益 + 收益
    交易次数 = 交易次数 + 1
    return null
```

### 不推荐

```DPLang
# ❌ 不推荐：频繁修改的临时状态
mut _临时计数 = 0  # 应该作为函数参数传递

# ❌ 不推荐：应该用局部变量
mut _临时结果 = 0  # 应该在函数内定义
```

## Lambda 表达式最佳实践

### 简洁的单表达式

```DPLang
# ✅ 好：简洁清晰
doubled = map(array, x -> x * 2)
filtered = filter(prices, p -> p > 100)
sum = reduce(values, (a, b) -> a + b)
```

### 使用有意义的参数名

```DPLang
# ✅ 好：复杂逻辑用描述性参数名
高收益股票 = filter(
    stocks,
    stock -> stock.收益率 > 0.1 and stock.风险度 < 0.5
)

# ❌ 差：复杂逻辑用单字母
高收益股票 = filter(
    stocks,
    s -> s.收益率 > 0.1 and s.风险度 < 0.5  # 不够清晰
)
```

### 读取外部变量

```DPLang
# ✅ 好：读取外部变量
阈值 = 100
倍数 = 2

result = prices
    |> filter(p -> p > 阈值)
    |> map(p -> p * 倍数)

# ❌ 错：试图修改外部变量
计数 = 0
map(array, x -> 计数 = 计数 + 1)  # 编译错误
```

### 管道链式调用

```DPLang
# ✅ 好：清晰的数据处理流程
成本 = 100
高收益阈值 = 50

result = prices
    |> filter(p -> p > 成本)          # 筛选
    |> map(p -> p - 成本)             # 转换
    |> filter(profit -> profit > 高收益阈值)  # 再筛选
    |> reduce((sum, p) -> sum + p)    # 聚合

# ❌ 差：嵌套调用难读
result = reduce(
    filter(
        map(
            filter(prices, p -> p > 成本),
            p -> p - 成本
        ),
        profit -> profit > 高收益阈值
    ),
    (sum, p) -> sum + p
)
```

### 避免过于复杂的表达式

```DPLang
# ❌ 差：逻辑太复杂
complex = map(
    array,
    x -> x > 10 ? (x < 20 ? (x % 2 == 0 ? x * 2 : x * 3) : x * 4) : x * 0.5
)

# ✅ 好：复杂逻辑用包函数
package 工具包

计算倍数(x:number) -> number:
    if x > 10:
        if x < 20:
            return x % 2 == 0 ? x * 2 : x * 3
        return x * 4
    return x * 0.5

# 数据脚本中使用
result = map(array, x -> 工具包.计算倍数(x))
```

## 高精度计算

### 金融计算使用 decimal

```DPLang
-- PRECISION decimal --

# ✅ 好：金融计算用 decimal
买入价 = decimal(100.123)
卖出价 = decimal(101.456)
股数 = 1000

盈利 = (卖出价 - 买入价) * 股数
手续费 = 盈利 * decimal(0.0003)
实际收益 = 盈利 - 手续费

# 四舍五入到分
实际收益 = round(实际收益, 2)

# ❌ 差：浮点数精度问题
买入价 = 100.123  # number 类型
卖出价 = 101.456
盈利 = (卖出价 - 买入价) * 1000  # 可能有精度误差
```

## 性能优化

### 避免重复计算

```DPLang
# ✅ 好：时间序列只计算一次（引用语义）
历史数据 = close[-20:0]
最大值 = max(...历史数据)
最小值 = min(...历史数据)
平均值 = mean(历史数据)

# ❌ 差：重复计算（低效）
最大值 = max(...close[-20:0])
最小值 = min(...close[-20:0])
平均值 = mean(close[-20:0])
```

### 使用安全函数避免异常

```DPLang
# ✅ 好：使用安全函数
涨幅 = safe_div(close - open, open, default=0.0)
昨收 = safe_get(历史数据, -1, default=close)

# ❌ 差：手动检查（冗长且可能遗漏）
if open != 0:
    涨幅 = (close - open) / open
else:
    涨幅 = 0.0

if len(历史数据) > 0:
    昨收 = 历史数据[-1]
else:
    昨收 = close
```

### 管道优化

```DPLang
# ✅ 好：先过滤减少数据量，再映射
result = large_array
    |> filter(x -> x > 阈值)  # 先过滤
    |> map(x -> 复杂计算(x))   # 对少量数据进行复杂计算

# ❌ 差：先映射大量数据，再过滤
result = large_array
    |> map(x -> 复杂计算(x))   # 对所有数据计算
    |> filter(x -> x > 阈值)  # 然后过滤
```

## 错误处理最佳实践

### ERROR 块处理异常

```DPLang
# ✅ 好：使用 ERROR 块处理意外错误
-- ERROR --
if _error.type == "ZeroDivision":
    return [code, 0, "除零错误"]
if _error.type == "NullReference":
    return null  # 过滤该行
exit("严重错误: " + _error.message)
-- ERROR_END --

# 业务逻辑
昨收 = close[-1]
涨跌幅 = (close - 昨收) / 昨收 * 100
```

### 安全函数处理可预见错误

```DPLang
# ✅ 好：可预见的错误用安全函数
涨幅 = safe_div(close - open, open, default=0.0)
历史数据 = close[-20:0]
昨日价 = safe_get(历史数据, 0, default=close)
```

### 结合使用

```DPLang
# ✅ 好：结合使用
-- ERROR --
# ERROR 块处理意外错误
if _error.type == "TypeError":
    return null  # 类型错误，过滤
exit("意外错误 at line " + string(_error.line) + ": " + _error.message)
-- ERROR_END --

# 可预见的错误用安全函数
涨幅 = safe_div(close - open, open, default=0.0)
昨收 = safe_get(close[-5:], -1, default=close)
量比 = safe_div(volume, mean(volume[-5:]), default=1.0)

return [code, 涨幅, 量比]
```

## 代码组织

### 数据脚本结构

```DPLang
-- INPUT ... --
-- OUTPUT ... --

# 1. 错误处理声明
-- ERROR --
...
-- ERROR_END --

# 2. 获取历史数据
历史数据 = close[-20:0]
昨收 = close[-1]

# 3. 计算基础指标
ma5 = MA(close, 5)
ma10 = MA(close, 10)

# 4. 计算派生指标
涨幅 = safe_div(close - 昨收, 昨收, default=0.0)
是否新高 = close >= max(...历史数据)

# 5. 业务逻辑
if 涨幅 > 0 and 是否新高:
    return [code, "强势", 涨幅]
else:
    return null
```

### 包脚本结构

```DPLang
package 包名

# 1. 包级常量
常量1 = 100
常量2 = 200

# 2. 私有配置
_私有常量 = 300

# 3. 包级可变状态
mut 状态1 = 0
mut _私有状态 = 0

# 4. 公开函数
公开函数1(参数):
    ...

公开函数2(参数):
    ...

# 5. 私有函数
_私有函数1(参数):
    ...

_私有函数2(参数):
    ...
```

## 注释规范

### 有意义的注释

```DPLang
# ✅ 好：解释业务逻辑
# 根据波动率动态调整均线周期，波动大用短周期（更灵敏）
动态周期 = volatility > 0.05 ? 5 : (volatility < 0.02 ? 30 : 10)
动态均线 = MA(close, 动态周期)

# ✅ 好：解释复杂计算
# 计算相对强度：(当前涨幅 / 市场平均涨幅) * 量比
相对强度 = (涨幅 / 市场涨幅) * 量比

# ❌ 差：重复代码内容
# 计算ma5
ma5 = MA(close, 5)  # 不需要这种注释

# ❌ 差：过时或错误的注释
# 计算10日均线
ma5 = MA(close, 5)  # 注释与代码不符
```

### 分段注释

```DPLang
# ========== 获取历史数据 ==========
历史20天 = past(close, 20, true)
历史成交量 = past(volume, 5)

# ========== 计算技术指标 ==========
ma5 = MA(close, 5)
ma10 = MA(close, 10)
[dif, dea, macd] = MACD(close, 12, 26, 9)

# ========== 信号判断 ==========
趋势向上 = ma5 > ma10
macd金叉 = dif > dea
```

## 测试建议

### 边界条件测试

```DPLang
# 测试数据
# - 空值处理
# - 除零情况
# - 数组越界
# - 类型错误

-- ERROR --
if _error.type == "ZeroDivision":
    return [code, 0]  # 除零返回0
if _error.type == "NullReference":
    return null  # 空值过滤
-- ERROR_END --

# 使用安全函数
涨幅 = safe_div(close - open, open, default=0.0)
```

### 性能测试

```DPLang
# 大数据量测试
# - 历史数据引用（不复制）
# - 管道优化（先过滤）
# - 避免重复计算

历史数据 = close[-100:0]  # 引用，不复制

# 先过滤再计算
result = large_dataset
    |> filter(x -> x > 阈值)
    |> map(x -> 复杂计算(x))
```
