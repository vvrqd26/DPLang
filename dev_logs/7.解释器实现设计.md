# DPLang v1.3 - 解释器实现设计

> 本文档详细描述 DPLang 解释器的核心架构、模块设计和实现细节

## 总体架构

```
┌─────────────────────────────────────────────────────────────┐
│                     DPLang 解释器                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────┐         │
│  │  Lexer     │─→│   Parser    │─→│  AST Builder │         │
│  │ 词法分析    │  │  语法分析    │  │  语法树构建   │         │
│  └────────────┘  └─────────────┘  └──────────────┘         │
│                           ↓                                 │
│                  ┌─────────────────┐                        │
│                  │ Semantic Analyzer│                       │
│                  │   语义分析器      │                       │
│                  │ - 作用域检查      │                       │
│                  │ - 类型检查        │                       │
│                  │ - 遮蔽检测        │                       │
│                  └─────────────────┘                        │
│                           ↓                                 │
│         ┌────────────────┴────────────────┐                │
│         ↓                                  ↓                │
│  ┌─────────────┐                  ┌──────────────┐         │
│  │ Package     │                  │ Data Script  │         │
│  │ Executor    │                  │ Executor     │         │
│  │ 包执行器     │                  │ 数据执行器    │         │
│  └─────────────┘                  └──────────────┘         │
│         ↓                                  ↓                │
│  ┌─────────────────────────────────────────────┐           │
│  │         Runtime Environment               │           │
│  │         - 变量存储                         │           │
│  │         - 函数注册表                       │           │
│  │         - 错误处理器                       │           │
│  │         - 内存管理                         │           │
│  └─────────────────────────────────────────────┘           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## 核心模块设计

### 1. Lexer（词法分析器）

#### 1.1 Token 定义

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    // 关键字
    Return,
    If,
    Else,
    Package,
    Mut,
    Null,
    True,
    False,
    
    // 特殊标记
    Input,      // -- INPUT
    Output,     // -- OUTPUT
    Error,      // -- ERROR --
    ErrorEnd,   // -- ERROR_END --
    Precision,  // -- PRECISION
    
    // 标识符和字面量
    Identifier(String),  // 变量名、函数名（支持中文）
    Number(f64),         // 数字字面量
    String(String),      // 字符串字面量
    
    // 运算符
    Plus,        // +
    Minus,       // -
    Star,        // *
    Slash,       // /
    Percent,     // %
    Caret,       // ^
    
    // 比较运算符
    Greater,     // >
    Less,        // <
    GreaterEq,   // >=
    LessEq,      // <=
    Equal,       // ==
    NotEqual,    // !=
    
    // 逻辑运算符
    And,         // and
    Or,          // or
    Not,         // not
    
    // 赋值和箭头
    Assign,      // =
    Arrow,       // ->
    Pipeline,    // |>
    
    // 括号和分隔符
    LeftParen,   // (
    RightParen,  // )
    LeftBracket, // [
    RightBracket,// ]
    LeftBrace,   // {
    RightBrace,  // }
    Comma,       // ,
    Colon,       // :
    Question,    // ?
    Spread,      // ...
    Dot,         // .
    Underscore,  // _
    
    // 特殊
    Newline,     // 换行
    Indent,      // 缩进
    Dedent,      // 反缩进
    Eof,         // 文件结束
    Comment,     // 注释（跳过）
}

#[derive(Debug, Clone)]
pub struct Token {
    pub token_type: TokenType,
    pub lexeme: String,
    pub line: usize,
    pub column: usize,
}
```

#### 1.2 Lexer 实现要点

```rust
pub struct Lexer {
    source: Vec<char>,
    current: usize,
    line: usize,
    column: usize,
    indent_stack: Vec<usize>,  // 缩进栈
}

impl Lexer {
    // 核心方法
    pub fn new(source: &str) -> Self;
    pub fn next_token(&mut self) -> Result<Token, LexError>;
    
    // 辅助方法
    fn skip_whitespace(&mut self);
    fn skip_comment(&mut self);
    fn scan_number(&mut self) -> Result<Token, LexError>;
    fn scan_string(&mut self) -> Result<Token, LexError>;
    fn scan_identifier(&mut self) -> Result<Token, LexError>;
    fn handle_indent(&mut self) -> Vec<Token>;  // 处理缩进变化
    
    // 中文标识符支持
    fn is_identifier_start(ch: char) -> bool {
        ch.is_alphabetic() || ch == '_' || is_chinese_char(ch)
    }
    
    fn is_identifier_continue(ch: char) -> bool {
        ch.is_alphanumeric() || ch == '_' || is_chinese_char(ch)
    }
}
```

**关键实现点：**
- ✅ 支持中文标识符（变量名、函数名）
- ✅ 缩进敏感（使用 Indent/Dedent Token）
- ✅ 注释处理（`#` 开头，跳过）
- ✅ 特殊声明识别（`-- INPUT --`、`-- ERROR --` 等）
- ✅ 管道运算符 `|>` 和箭头 `->`

### 2. Parser（语法分析器）

#### 2.1 AST 节点定义

```rust
// 表达式节点
#[derive(Debug, Clone)]
pub enum Expr {
    // 字面量
    Number(f64),
    String(String),
    Bool(bool),
    Null,
    
    // 标识符
    Identifier(String),
    
    // 数组
    Array(Vec<Expr>),
    
    // 二元运算
    Binary {
        left: Box<Expr>,
        op: BinaryOp,
        right: Box<Expr>,
    },
    
    // 一元运算
    Unary {
        op: UnaryOp,
        operand: Box<Expr>,
    },
    
    // 三元表达式
    Ternary {
        condition: Box<Expr>,
        then_expr: Box<Expr>,
        else_expr: Box<Expr>,
    },
    
    // 函数调用
    Call {
        callee: String,  // 函数名（可能带包前缀）
        args: Vec<Expr>,
    },
    
    // 成员访问（包.成员）
    MemberAccess {
        object: String,  // 包名
        member: String,  // 成员名
    },
    
    // 数组索引
    Index {
        array: Box<Expr>,
        index: Box<Expr>,
    },
    
    // 展开运算符
    Spread(Box<Expr>),
    
    // Lambda 表达式
    Lambda {
        params: Vec<String>,
        body: Box<Expr>,
        captures: Vec<String>,  // 捕获的外部变量（只读）
    },
    
    // 管道表达式
    Pipeline {
        value: Box<Expr>,
        stages: Vec<Expr>,  // 管道的各个阶段
    },
}

// 语句节点
#[derive(Debug, Clone)]
pub enum Stmt {
    // 变量赋值
    Assignment {
        name: String,
        value: Expr,
        is_mut: bool,  // 仅包脚本使用
    },
    
    // 解构赋值
    Destructure {
        pattern: Vec<DestructurePattern>,
        value: Expr,
    },
    
    // 条件语句
    If {
        condition: Expr,
        then_block: Vec<Stmt>,
        else_block: Option<Vec<Stmt>>,
    },
    
    // 返回语句
    Return(Expr),
    
    // 表达式语句
    Expression(Expr),
}

// 解构模式
#[derive(Debug, Clone)]
pub enum DestructurePattern {
    Identifier(String),
    Ignore,  // _
    Spread(String),  // ...rest
}

// 二元运算符
#[derive(Debug, Clone, Copy)]
pub enum BinaryOp {
    // 算术
    Add, Sub, Mul, Div, Mod, Pow,
    // 比较
    Gt, Lt, GtEq, LtEq, Eq, NotEq,
    // 逻辑
    And, Or,
}

// 一元运算符
#[derive(Debug, Clone, Copy)]
pub enum UnaryOp {
    Neg,  // -
    Not,  // not
}

// 函数定义
#[derive(Debug, Clone)]
pub struct FunctionDef {
    pub name: String,
    pub params: Vec<Parameter>,
    pub return_type: Option<TypeAnnotation>,
    pub body: Vec<Stmt>,
    pub is_private: bool,  // 是否以 _ 开头
}

#[derive(Debug, Clone)]
pub struct Parameter {
    pub name: String,
    pub type_annotation: Option<TypeAnnotation>,
}

// 类型标注
#[derive(Debug, Clone, PartialEq)]
pub enum TypeAnnotation {
    Number,
    Decimal,
    String,
    Bool,
    Array,
    Null,
}

// 脚本类型
#[derive(Debug, Clone)]
pub enum Script {
    // 包脚本
    Package {
        name: String,
        variables: Vec<VariableDef>,
        functions: Vec<FunctionDef>,
    },
    
    // 数据处理脚本
    DataScript {
        input: Vec<Parameter>,
        output: Vec<Parameter>,
        error_block: Option<Vec<Stmt>>,
        precision: Option<TypeAnnotation>,  // decimal 精度模式
        body: Vec<Stmt>,
    },
}

#[derive(Debug, Clone)]
pub struct VariableDef {
    pub name: String,
    pub value: Expr,
    pub is_mut: bool,
    pub is_private: bool,
}
```

#### 2.2 Parser 实现要点

```rust
pub struct Parser {
    tokens: Vec<Token>,
    current: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self;
    pub fn parse(&mut self) -> Result<Script, ParseError>;
    
    // 脚本解析
    fn parse_package_script(&mut self) -> Result<Script, ParseError>;
    fn parse_data_script(&mut self) -> Result<Script, ParseError>;
    
    // 声明解析
    fn parse_input_output(&mut self) -> Result<Vec<Parameter>, ParseError>;
    fn parse_error_block(&mut self) -> Result<Vec<Stmt>, ParseError>;
    
    // 语句解析
    fn parse_statement(&mut self) -> Result<Stmt, ParseError>;
    fn parse_assignment(&mut self) -> Result<Stmt, ParseError>;
    fn parse_if_statement(&mut self) -> Result<Stmt, ParseError>;
    fn parse_return_statement(&mut self) -> Result<Stmt, ParseError>;
    
    // 表达式解析（优先级递归下降）
    fn parse_expression(&mut self) -> Result<Expr, ParseError>;
    fn parse_pipeline(&mut self) -> Result<Expr, ParseError>;      // |> 最低优先级
    fn parse_ternary(&mut self) -> Result<Expr, ParseError>;       // ? :
    fn parse_or(&mut self) -> Result<Expr, ParseError>;            // or
    fn parse_and(&mut self) -> Result<Expr, ParseError>;           // and
    fn parse_comparison(&mut self) -> Result<Expr, ParseError>;    // > < >= <= == !=
    fn parse_addition(&mut self) -> Result<Expr, ParseError>;      // + -
    fn parse_multiplication(&mut self) -> Result<Expr, ParseError>;// * / %
    fn parse_power(&mut self) -> Result<Expr, ParseError>;         // ^
    fn parse_unary(&mut self) -> Result<Expr, ParseError>;         // - not
    fn parse_call(&mut self) -> Result<Expr, ParseError>;          // 函数调用
    fn parse_primary(&mut self) -> Result<Expr, ParseError>;       // 基础表达式
    
    // Lambda 解析
    fn parse_lambda(&mut self) -> Result<Expr, ParseError>;
    
    // 函数定义解析
    fn parse_function_def(&mut self) -> Result<FunctionDef, ParseError>;
    
    // 辅助方法
    fn match_token(&mut self, types: &[TokenType]) -> bool;
    fn consume(&mut self, token_type: TokenType, msg: &str) -> Result<Token, ParseError>;
    fn peek(&self) -> &Token;
    fn is_at_end(&self) -> bool;
}
```

**关键实现点：**
- ✅ 运算符优先级正确处理（递归下降）
- ✅ 管道运算符 `|>` 优先级最低
- ✅ Lambda 表达式解析（单表达式）
- ✅ 解构赋值支持（`[a, b, c] = ...`）
- ✅ 展开运算符支持（`...`）
- ✅ 缩进块处理（if/else、函数体）

### 3. Semantic Analyzer（语义分析器）

#### 3.1 作用域管理

```rust
// 作用域类型
#[derive(Debug, Clone)]
pub enum ScopeType {
    Global,           // 全局作用域
    Package(String),  // 包作用域
    Function(String), // 函数作用域
    DataScript,       // 数据脚本作用域
    Lambda,           // Lambda 作用域
}

// 符号信息
#[derive(Debug, Clone)]
pub struct Symbol {
    pub name: String,
    pub symbol_type: SymbolType,
    pub is_mutable: bool,
    pub is_private: bool,
    pub declared_line: usize,
}

#[derive(Debug, Clone)]
pub enum SymbolType {
    Variable(Option<TypeAnnotation>),
    Function {
        params: Vec<TypeAnnotation>,
        return_type: Option<TypeAnnotation>,
    },
    Parameter(Option<TypeAnnotation>),
    LambdaParam,
}

// 作用域栈
pub struct ScopeStack {
    scopes: Vec<Scope>,
}

pub struct Scope {
    scope_type: ScopeType,
    symbols: HashMap<String, Symbol>,
    parent: Option<usize>,  // 父作用域索引
}

impl ScopeStack {
    pub fn new() -> Self;
    pub fn push_scope(&mut self, scope_type: ScopeType);
    pub fn pop_scope(&mut self);
    
    // 符号操作
    pub fn declare(&mut self, symbol: Symbol) -> Result<(), SemanticError>;
    pub fn lookup(&self, name: &str) -> Option<&Symbol>;
    pub fn lookup_in_current(&self, name: &str) -> Option<&Symbol>;
    
    // 遮蔽检测（关键！）
    pub fn check_shadowing(&self, name: &str) -> Result<(), SemanticError>;
}
```

#### 3.2 语义分析器实现

```rust
pub struct SemanticAnalyzer {
    scope_stack: ScopeStack,
    current_package: Option<String>,
    errors: Vec<SemanticError>,
    type_registry: TypeRegistry,
}

impl SemanticAnalyzer {
    pub fn new() -> Self;
    pub fn analyze(&mut self, script: &Script) -> Result<(), SemanticError>;
    
    // 脚本分析
    fn analyze_package(&mut self, script: &Script) -> Result<(), SemanticError>;
    fn analyze_data_script(&mut self, script: &Script) -> Result<(), SemanticError>;
    
    // 语句分析
    fn analyze_statement(&mut self, stmt: &Stmt) -> Result<(), SemanticError>;
    fn analyze_assignment(&mut self, name: &str, value: &Expr) -> Result<(), SemanticError>;
    fn analyze_if(&mut self, stmt: &Stmt) -> Result<(), SemanticError>;
    
    // 表达式分析
    fn analyze_expr(&mut self, expr: &Expr) -> Result<InferredType, SemanticError>;
    fn analyze_lambda(&mut self, lambda: &Expr) -> Result<InferredType, SemanticError>;
    
    // 类型检查
    fn check_type_compatibility(
        &self,
        expected: &TypeAnnotation,
        actual: &InferredType
    ) -> Result<(), SemanticError>;
    
    // 遮蔽检测（核心！）
    fn check_no_shadowing(&mut self, name: &str, line: usize) -> Result<(), SemanticError> {
        // 检查当前作用域和所有父作用域
        if self.scope_stack.lookup(name).is_some() {
            return Err(SemanticError::VariableShadowing {
                name: name.to_string(),
                line,
            });
        }
        Ok(())
    }
    
    // Lambda 特殊检查
    fn check_lambda_constraints(&mut self, lambda: &Expr) -> Result<(), SemanticError> {
        // 1. 参数名不能遮蔽外部变量
        // 2. 不能修改外部变量
        // 3. 不能定义新变量
        // 4. 只能是单表达式
    }
    
    // 访问控制检查
    fn check_member_access(&self, package: &str, member: &str) -> Result<(), SemanticError>;
}

#[derive(Debug, Clone)]
pub enum SemanticError {
    VariableShadowing { name: String, line: usize },
    UndefinedVariable { name: String, line: usize },
    TypeMismatch { expected: String, actual: String, line: usize },
    PrivateMemberAccess { package: String, member: String, line: usize },
    LambdaModifiesExternal { name: String, line: usize },
    LambdaDefinesVariable { name: String, line: usize },
    LambdaParamShadowing { param: String, shadowed: String, line: usize },
    DataScriptDefinesFunction { name: String, line: usize },
    MutatePackageState { package: String, var: String, line: usize },
    // ... 其他错误
}
```

**关键实现点：**
- ✅ **完全禁止变量遮蔽**（编译期检测所有作用域）
- ✅ Lambda 参数不能遮蔽外部变量
- ✅ Lambda 不能修改外部变量（只读捕获）
- ✅ Lambda 不能定义新变量
- ✅ 私有成员访问控制（`_` 前缀）
- ✅ 数据脚本不能定义函数
- ✅ 数据脚本不能修改包级状态

### 4. Type System（类型系统）

#### 4.1 类型推导

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum InferredType {
    Number,
    Decimal,
    String,
    Bool,
    Null,
    Array(Box<InferredType>),  // 数组元素类型
    Function {
        params: Vec<InferredType>,
        return_type: Box<InferredType>,
    },
    Unknown,  // 无法推导
}

pub struct TypeRegistry {
    // 内置函数签名
    builtin_functions: HashMap<String, FunctionSignature>,
    // 用户定义函数签名
    user_functions: HashMap<String, FunctionSignature>,
    // 包成员类型
    package_members: HashMap<String, HashMap<String, InferredType>>,
}

#[derive(Debug, Clone)]
pub struct FunctionSignature {
    pub params: Vec<InferredType>,
    pub return_type: InferredType,
}

impl TypeRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            builtin_functions: HashMap::new(),
            user_functions: HashMap::new(),
            package_members: HashMap::new(),
        };
        registry.register_builtins();
        registry
    }
    
    fn register_builtins(&mut self) {
        // 数学函数
        self.register_builtin("abs", vec![InferredType::Number], InferredType::Number);
        self.register_builtin("max", vec![/* 可变参数 */], InferredType::Number);
        // ... 注册所有内置函数
        
        // 高阶函数
        self.register_builtin("map", vec![
            InferredType::Array(Box::new(InferredType::Unknown)),
            InferredType::Function { /* Lambda */ },
        ], InferredType::Array(Box::new(InferredType::Unknown)));
        
        // 时间序列函数
        self.register_builtin("past", vec![
            InferredType::Array(Box::new(InferredType::Unknown)),
            InferredType::Number,
        ], InferredType::Array(Box::new(InferredType::Unknown)));
    }
    
    pub fn infer_type(&self, expr: &Expr, context: &ScopeStack) -> Result<InferredType, TypeError>;
    pub fn check_assignment(&self, var_type: &InferredType, value_type: &InferredType) -> bool;
}
```

**关键实现点：**
- ✅ number 类型自动提升（int → float）
- ✅ 位宽自动提升（int32 → int64）
- ✅ 向量运算类型检查
- ✅ Lambda 表达式类型推导
- ✅ 函数签名验证

### 5. Runtime（运行时环境）

#### 5.1 值表示

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Number(NumberValue),
    Decimal(rust_decimal::Decimal),
    String(String),
    Bool(bool),
    Null,
    Array(Vec<Value>),
    // 引用类型（时间序列）
    ArrayRef {
        data: Rc<Vec<Value>>,  // 共享所有权
        start: usize,
        len: usize,
    },
}

#[derive(Debug, Clone, PartialEq)]
pub enum NumberValue {
    Int32(i32),
    Int64(i64),
    Float64(f64),
}

impl Value {
    // 自动类型提升
    pub fn promote_number(self) -> Value;
    
    // 类型转换
    pub fn to_number(&self) -> Result<NumberValue, RuntimeError>;
    pub fn to_decimal(&self) -> Result<rust_decimal::Decimal, RuntimeError>;
    pub fn to_string(&self) -> String;
    pub fn to_bool(&self) -> bool;
    
    // 运算
    pub fn add(&self, other: &Value) -> Result<Value, RuntimeError>;
    pub fn sub(&self, other: &Value) -> Result<Value, RuntimeError>;
    // ... 其他运算
}
```

#### 5.2 执行上下文

```rust
pub struct ExecutionContext {
    // 变量存储（当前作用域）
    variables: HashMap<String, Value>,
    
    // 函数注册表（全局）
    functions: Arc<HashMap<String, CompiledFunction>>,
    
    // 包状态（全局）
    packages: Arc<RwLock<HashMap<String, PackageState>>>,
    
    // 内置变量（数据脚本）
    builtin_vars: BuiltinVars,
    
    // 错误处理器
    error_handler: Option<ErrorHandler>,
}

#[derive(Debug, Clone)]
pub struct BuiltinVars {
    pub args: Vec<Value>,          // _args
    pub args_names: Vec<String>,   // _args_names
    pub index: usize,              // _index
    pub total: usize,              // _total
}

#[derive(Debug, Clone)]
pub struct PackageState {
    pub name: String,
    pub variables: HashMap<String, Value>,  // 包级变量
    pub functions: HashMap<String, CompiledFunction>,
}

#[derive(Debug, Clone)]
pub struct ErrorHandler {
    pub error_block: Vec<Stmt>,  // ERROR 块代码
}

pub struct CompiledFunction {
    pub name: String,
    pub params: Vec<String>,
    pub body: Vec<Stmt>,
    pub is_private: bool,
}
```

#### 5.3 执行器

```rust
pub struct Executor {
    context: ExecutionContext,
}

impl Executor {
    pub fn new() -> Self;
    
    // 执行语句
    pub fn execute_stmt(&mut self, stmt: &Stmt) -> Result<ExecutionResult, RuntimeError>;
    
    // 执行表达式
    pub fn execute_expr(&mut self, expr: &Expr) -> Result<Value, RuntimeError>;
    
    // 函数调用
    pub fn call_function(
        &mut self,
        name: &str,
        args: Vec<Value>
    ) -> Result<Value, RuntimeError>;
    
    // Lambda 执行
    pub fn execute_lambda(
        &mut self,
        lambda: &Expr,
        args: Vec<Value>,
        captured_vars: &HashMap<String, Value>
    ) -> Result<Value, RuntimeError>;
    
    // 错误处理
    pub fn handle_error(&mut self, error: RuntimeError) -> Result<ExecutionResult, RuntimeError>;
}

#[derive(Debug, Clone)]
pub enum ExecutionResult {
    Continue,
    Return(Value),
    Exit(String),
}

#[derive(Debug, Clone)]
pub struct RuntimeError {
    pub error_type: ErrorType,
    pub message: String,
    pub line: usize,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ErrorType {
    ZeroDivision,
    TypeError,
    IndexOutOfBounds,
    NullReference,
    UndefinedFunction,
    ArgumentMismatch,
}
```

### 6. 内置函数库

#### 6.1 时间序列函数（引用语义）

```rust
pub mod timeseries {
    use super::*;
    
    // past() - 引用语义，不复制数据
    pub fn past(
        field_data: &[Value],  // 完整时间序列
        current_index: usize,
        n: usize,
        include_current: bool
    ) -> Value {
        let end = if include_current { current_index + 1 } else { current_index };
        let start = end.saturating_sub(n);
        
        // 返回引用，不复制数据
        Value::ArrayRef {
            data: Rc::new(field_data[start..end].to_vec()),
            start,
            len: end - start,
        }
    }
    
    // offset() - 单个值访问
    pub fn offset(
        field_data: &[Value],
        current_index: usize,
        offset: isize
    ) -> Value {
        let target_index = (current_index as isize + offset) as usize;
        if target_index >= field_data.len() {
            return Value::Null;
        }
        field_data[target_index].clone()
    }
    
    // window() - 窗口数据，引用语义
    pub fn window(
        field_data: &[Value],
        current_index: usize,
        start_offset: isize,
        end_offset: isize
    ) -> Value {
        // ... 实现
    }
}
```

#### 6.2 高阶函数

```rust
pub mod higher_order {
    use super::*;
    
    // map() - 映射转换
    pub fn map(
        executor: &mut Executor,
        array: Value,
        lambda: &Expr
    ) -> Result<Value, RuntimeError> {
        let arr = array.as_array()?;
        let mut result = Vec::new();
        
        for (index, item) in arr.iter().enumerate() {
            let value = executor.execute_lambda(
                lambda,
                vec![item.clone(), Value::Number(NumberValue::Int32(index as i32))],
                &HashMap::new()  // 外部变量捕获
            )?;
            result.push(value);
        }
        
        Ok(Value::Array(result))
    }
    
    // filter() - 过滤筛选
    pub fn filter(
        executor: &mut Executor,
        array: Value,
        lambda: &Expr
    ) -> Result<Value, RuntimeError> {
        let arr = array.as_array()?;
        let mut result = Vec::new();
        
        for item in arr.iter() {
            let keep = executor.execute_lambda(
                lambda,
                vec![item.clone()],
                &HashMap::new()
            )?;
            
            if keep.to_bool() {
                result.push(item.clone());
            }
        }
        
        Ok(Value::Array(result))
    }
    
    // reduce() - 归约聚合
    pub fn reduce(
        executor: &mut Executor,
        array: Value,
        init: Option<Value>,
        lambda: &Expr
    ) -> Result<Value, RuntimeError> {
        // ... 实现
    }
}
```

### 7. 解释器主流程

```rust
pub struct Interpreter {
    lexer: Lexer,
    parser: Parser,
    analyzer: SemanticAnalyzer,
    executor: Executor,
}

impl Interpreter {
    pub fn new() -> Self;
    
    // 完整执行流程
    pub fn run(&mut self, source: &str) -> Result<(), InterpreterError> {
        // 1. 词法分析
        let tokens = self.lexer.tokenize(source)?;
        
        // 2. 语法分析
        let ast = self.parser.parse(tokens)?;
        
        // 3. 语义分析（类型检查、作用域检查、遮蔽检测）
        self.analyzer.analyze(&ast)?;
        
        // 4. 执行
        match ast {
            Script::Package { .. } => self.execute_package(ast)?,
            Script::DataScript { .. } => self.execute_data_script(ast)?,
        }
        
        Ok(())
    }
    
    // 包脚本执行（一次性）
    fn execute_package(&mut self, script: Script) -> Result<(), RuntimeError> {
        // 1. 初始化包级变量
        // 2. 注册函数
        // 3. 执行初始化代码
    }
    
    // 数据脚本执行（逐行）
    fn execute_data_script(&mut self, script: Script) -> Result<Vec<Vec<Value>>, RuntimeError> {
        let mut output_rows = Vec::new();
        
        for (index, input_row) in self.input_data.iter().enumerate() {
            // 1. 创建新的执行上下文
            let mut context = ExecutionContext::new();
            context.builtin_vars.args = input_row.clone();
            context.builtin_vars.index = index;
            context.builtin_vars.total = self.input_data.len();
            
            // 2. 执行脚本
            match self.executor.execute_script(&script, context) {
                Ok(ExecutionResult::Return(value)) => {
                    if !value.is_null() {
                        output_rows.push(value.as_array()?);
                    }
                },
                Err(error) => {
                    // 3. 错误处理（跳转 ERROR 块）
                    if let Some(handler) = &script.error_block {
                        match self.executor.handle_error(error) {
                            Ok(ExecutionResult::Return(value)) => {
                                if !value.is_null() {
                                    output_rows.push(value.as_array()?);
                                }
                            },
                            Ok(ExecutionResult::Exit(msg)) => {
                                return Err(RuntimeError::Exit(msg));
                            },
                            _ => {}
                        }
                    } else {
                        return Err(error);
                    }
                }
                _ => {}
            }
            
            // 4. 销毁上下文（局部变量自动释放）
        }
        
        Ok(output_rows)
    }
}
```

## 内存管理策略

### 1. 无闭包设计

```rust
// ✅ Lambda 只读捕获，不形成闭包
pub struct LambdaContext {
    captured_vars: HashMap<String, Value>,  // 只读快照
    params: Vec<String>,
}

// Lambda 执行完立即销毁，无需 GC 追踪引用链
```

### 2. 禁止遮蔽优化

```rust
// ✅ 无遮蔽 = 变量名唯一 = 简单的符号表
pub struct VariableStorage {
    vars: HashMap<String, Value>,  // 扁平化存储
}

// 无需版本链、无需复杂的作用域嵌套查找
```

### 3. 引用语义（时间序列）

```rust
// ✅ 不复制数据，使用 Rc 共享所有权
Value::ArrayRef {
    data: Rc<Vec<Value>>,  // 共享引用
    start: usize,
    len: usize,
}

// 多个 past() 调用共享同一份数据
```

### 4. 栈式生命周期

```rust
// 数据脚本执行：
// 1. 创建执行上下文（栈）
// 2. 执行脚本
// 3. 返回结果
// 4. 销毁上下文（栈自动释放）

// 无需复杂的垃圾回收
```

## 并发安全模型

### 1. 包脚本：顺序执行

```rust
// 包脚本在解释器启动时顺序执行一次
// 包级 mut 变量只能在包内修改
// 数据脚本只能读取包级变量

pub struct PackageExecutor {
    // 顺序执行，无并发问题
    pub fn execute_in_order(&mut self, packages: Vec<Script>) {
        for package in packages {
            self.execute_package(package);
        }
    }
}
```

### 2. 数据脚本：纯函数并行

```rust
// 数据脚本是纯函数，可以并行执行

use rayon::prelude::*;

pub fn execute_data_parallel(
    &self,
    script: &Script,
    input_data: Vec<Vec<Value>>
) -> Vec<Option<Vec<Value>>> {
    input_data.par_iter().enumerate().map(|(index, row)| {
        // 每行独立执行，无副作用
        let mut executor = Executor::new();
        executor.execute_row(script, row, index)
    }).collect()
}
```

## 错误处理机制

### ERROR 块实现

```rust
// ERROR 块是延迟声明的错误处理函数
pub struct ErrorHandler {
    error_block: Vec<Stmt>,
}

impl Executor {
    pub fn execute_with_error_handling(
        &mut self,
        script: &Script
    ) -> Result<ExecutionResult, RuntimeError> {
        match self.execute_script(script) {
            Ok(result) => Ok(result),
            Err(error) => {
                // 发生错误，跳转 ERROR 块
                if let Some(handler) = &script.error_block {
                    // 设置 _error 内置变量
                    self.context.set_error_context(error.clone());
                    
                    // 执行 ERROR 块
                    for stmt in handler.error_block.iter() {
                        match self.execute_stmt(stmt)? {
                            ExecutionResult::Return(value) => return Ok(ExecutionResult::Return(value)),
                            ExecutionResult::Exit(msg) => return Ok(ExecutionResult::Exit(msg)),
                            _ => {}
                        }
                    }
                }
                Err(error)
            }
        }
    }
}
```

## 编译期优化

### 1. 常量折叠

```rust
// 编译期计算常量表达式
// 1 + 2 * 3  =>  7
```

### 2. 死代码消除

```rust
// 移除永不执行的代码
if false:
    ... // 编译期删除
```

### 3. 内联优化

```rust
// 简单函数内联
fn double(x): return x * 2
result = double(5)  =>  result = 5 * 2
```

## 性能优化

### 1. 时间序列数据复用

```rust
// 预加载完整时间序列，避免重复访问
pub struct TimeSeriesCache {
    fields: HashMap<String, Rc<Vec<Value>>>,
}
```

### 2. 向量化运算

```rust
// 向量运算直接操作数组，避免逐元素循环
impl Value {
    pub fn vector_add(&self, other: &Value) -> Result<Value, RuntimeError> {
        // SIMD 加速
    }
}
```

### 3. Lambda 编译缓存

```rust
// 缓存 Lambda 编译结果
pub struct LambdaCache {
    cache: HashMap<u64, CompiledLambda>,  // hash -> compiled
}
```

## 测试策略

### 1. 单元测试

- Lexer 测试：Token 识别、中文支持、缩进处理
- Parser 测试：AST 正确性、错误恢复
- Semantic 测试：遮蔽检测、类型检查、作用域验证
- Runtime 测试：值运算、函数调用、错误处理

### 2. 集成测试

- 完整脚本执行
- 包和数据脚本交互
- ERROR 块测试
- Lambda 和高阶函数

### 3. 性能测试

- 大数据量处理
- 并行执行效率
- 内存使用
- 时间序列引用性能

## 工具链支持（规划）

### 1. LSP 服务器

```rust
pub struct DPLangLSP {
    // 语法高亮
    // 自动补全
    // 错误提示
    // 跳转定义
    // 重构支持
}
```

### 2. 调试器

```rust
pub struct Debugger {
    // 断点管理
    // 变量查看
    // 单步执行
    // 调用栈追踪
}
```

### 3. 性能分析器

```rust
pub struct Profiler {
    // 热点函数识别
    // 内存分配分析
    // Lambda 性能优化建议
}
```

---

**文档版本：** v1.3  
**最后更新：** 2025-11-09
