# DPLang v1.3 - 核心设计

> DPLang 是一个高性能的领域化专用脚本语言，专门为金融分析设计，使用 Rust 语言实现。

## 脚本执行过程

```
开始
↓
初始化阶段：
  - 加载所有包脚本，执行包级变量初始化
  - 构建函数注册表（公开/私有函数）
  - 类型检查和语法验证
  - 变量遮蔽检测
↓
数据流处理阶段：
   对于每个数据处理脚本：
      验证INPUT/OUTPUT类型匹配
      注册ERROR块为延迟处理函数
      对于数据流中的每一行：
         创建新的执行上下文（清空局部变量）
         执行当前脚本
         如果发生异常：立即停止，跳转ERROR块
         如果返回非NULL：添加到新数据流
         否则：过滤掉该行
         销毁执行上下文（释放局部变量）
      将新数据流传递给下一个脚本
↓
结束（可选聚合阶段）
```

## 脚本特性

1. **自然语言友好** - 支持中文变量名和函数名，人类阅读友好
2. **轻量高效** - 可编译成字节码，可编译成 wasm 方便集成
3. **AI 友好** - 语法极简明确，学习成本低，节省 token
4. **内存管理简单** - 无闭包设计，GC 压力小
5. **天然并发安全** - 数据脚本为纯函数，可多线程执行
6. **类型安全** - 统一 number 类型，自动位宽/类型提升
7. **完全禁止变量遮蔽** - 编译期可检测所有作用域错误
8. **白盒解释器** - 可从外部获取公开状态，提供 MCP 工具
9. **可视化支持** - 可根据脚本生成流程图，支持节点化编程
10. **编译期检测** - 类型检查、未定义变量、变量遮蔽、私有成员访问、函数签名验证
11. **函数式编程** - 支持 Lambda 表达式和高阶函数，消除循环

## 核心设计原则

### 1. 变量不可变性

- **数据脚本**：所有变量默认不可变，无需关键字声明
- **包脚本**：默认不可变，使用 `mut` 声明可变状态

```DPLang
# 数据脚本
ma5 = MA(close, 5)
# ma5 = ma5 * 2  # ❌ 编译错误：禁止遮蔽

# 包脚本
package 工具包
常量 = 100           # 不可变
mut 计数 = 0         # 可变状态
```

### 2. 无变量遮蔽

- 完全禁止变量遮蔽，编译期报错
- 简化作用域分析，减少 GC 负担
- **强制数据处理流程简单化，每一步操作意义明确**

```DPLang
# ❌ 错误
ma5 = MA(close, 5)
ma5 = ma5 * 2  # 编译错误

# ✅ 正确
ma5 = MA(close, 5)
ma5_scaled = ma5 * 2
```

### 3. 无闭包特性

- 函数内变量完全隔离，函数返回后立即释放
- 无需追踪闭包引用链，GC 实现简单高效
- **Lambda 表达式只读捕获外部变量，不形成闭包**

```DPLang
# 函数内变量隔离
计算(x):
    temp = x * 2
    return temp
    # temp 立即销毁

# Lambda 只读捕获
阈值 = 10
filtered = filter(array, x -> x > 阈值)  # 只读引用，无闭包
```

### 4. 访问控制

- `_` 前缀表示私有（函数、变量）
- 默认公开访问
- **只有包脚本可以定义函数**

```DPLang
package 工具包

公开变量 = 100
_私有变量 = 200

公开函数():
    return 公开变量

_私有函数():
    return _私有变量
```

### 5. 纯函数数据脚本

- **数据脚本禁止修改外部变量**
- **数据脚本是无副作用的纯函数**
- **可安全并行执行，无竞态条件**

这是并发安全的核心保证：
- 包脚本：顺序执行，仅执行一次
- 数据脚本：纯函数，可并行执行

```DPLang
# 数据脚本是纯函数
-- INPUT code:string, close:number --
-- OUTPUT code:string, ma5:number --

ma5 = MA(close, 5)  # ✅ 局部计算
return [code, ma5]  # ✅ 无副作用

# 工具包.计数 = 工具包.计数 + 1  # ❌ 编译错误：禁止修改外部变量
```

## 作用域和生命周期

### 作用域层级

```
全局作用域
  └── 包作用域（package）
        ├── 包级变量（解释器启动时初始化，持续到解释器销毁）
        └── 函数作用域
              └── 函数局部变量（函数调用时创建，返回时销毁）
  
数据流作用域（每个数据处理脚本）
  └── 数据行作用域（每行数据）
        ├── 局部变量（执行当前行时创建，执行完毕后销毁）
        └── Lambda 作用域
              └── Lambda 参数（Lambda 执行时创建，执行完销毁）
                  └── 可读取外部变量（只读捕获，不形成闭包）
```

### 生命周期示例

```DPLang
# ========== 包脚本 ==========
package 示例包

# 生命周期：解释器启动 → 解释器销毁
常量A = 100
mut 状态B = 0

# 函数定义：解释器启动时注册
计算(x):
    # 生命周期：函数调用 → 函数返回
    临时变量 = x * 2
    
    # 修改包级状态（生命周期长）
    状态B = 状态B + 1
    
    return 临时变量
    # 临时变量销毁

# ========== 数据脚本 ==========
-- INPUT code:string, close:number --

# 第1行数据执行：
#   ma5 = MA(close, 5)  # 创建
#   return [code, ma5]   # 使用
#   # ma5销毁

# 第2行数据执行：
#   ma5 = MA(close, 5)  # 重新创建（新的变量）
#   return [code, ma5]
#   # ma5销毁

ma5 = MA(close, 5)

# Lambda 生命周期
阈值 = 10
历史数据 = close[-20:0]
# Lambda 执行时：
#   - 读取外部变量 阈值（只读引用）
#   - 创建参数 x
#   - 计算表达式
#   - 销毁参数 x
高于阈值 = filter(历史数据, x -> x > 阈值)

return [code, ma5]
```

### 内存管理优势

```DPLang
# 无闭包 = 简单栈管理
计算指标(close):
    ma5 = MA(close, 5)
    ma10 = MA(close, 10)
    diff = ma5 - ma10
    return diff
    # ma5, ma10, diff 立即从栈弹出，无需GC追踪

# 禁止遮蔽 = 无需版本链
ma5 = MA(close, 5)
# ma5 = ma5 * 2  # ❌ 禁止
ma5_scaled = ma5 * 2  # ✅ 新变量，清晰的内存布局

# 不可变 = 无需拷贝写入（Copy-on-Write）
历史数据 = close[-20:]  # 引用语义，无需拷贝
最大值 = max(...历史数据)    # 安全读取

# Lambda 只读捕获 = 不形成闭包
阈值 = 10
filtered = filter(array, x -> x > 阈值)  # 阈值只读引用，无闭包
# filtered 执行完，Lambda 立即销毁，无需追踪引用链
```

## 编译期错误检测

解释器在执行前会进行以下检查：

### 1. 语法检查
- 关键字拼写错误
- 括号/引号匹配
- 缩进一致性（if/else块）
- return 语句位置
- Lambda 表达式语法正确性

### 2. 类型检查
- INPUT/OUTPUT 类型声明匹配
- 函数签名类型匹配（如果有类型标注）
- 返回值类型与 OUTPUT 声明一致
- 类型转换合法性

### 3. 作用域检查
- **未定义变量引用**
- **变量遮蔽检测（完全禁止）**
- **Lambda 参数名与外部变量冲突检测**
- 函数未定义
- 包不存在
- 私有成员访问检查

### 4. 语义检查
- 数据脚本不能定义函数
- 只有包内可修改 mut 变量
- 函数内变量不可外部访问
- 返回值结构与 OUTPUT 一致
- Lambda 表达式不能修改外部变量
- Lambda 表达式不能定义新变量

## 版本演进对比

| 特性 | v1.0 | v1.1 | v1.2 | v1.3 |
|------|------|------|------|------|
| 变量声明 | 隐式 | let/const | 无关键字 | 无关键字 |
| 函数定义 | fn关键字 | fn关键字 | 无fn（冒号识别） | 无fn（冒号识别） |
| 数值类型 | int/float分离 | int/float分离 | number统一 | number统一 |
| 变量遮蔽 | 允许 | 允许 | 完全禁止 | 完全禁止 |
| 闭包 | 未定义 | 未定义 | 明确禁止 | 明确禁止 |
| Lambda | 不支持 | 不支持 | 未定义 | ✅ 支持（只读捕获） |
| 循环 | for/while | 保留字 | 保留字 | ❌ 无（高阶函数代替） |
| 错误处理 | try-catch | 宏+安全函数 | 宏+安全函数 | ✅ ERROR块+安全函数 |
| 并发安全 | 未定义 | 未定义 | 未定义 | ✅ 纯函数数据脚本 |
| 管道运算符 | 不支持 | 不支持 | 不支持 | ✅ 支持 `\|>` |
| Token效率 | 中 | 中 | 高 | 高 |
| 语法简洁度 | 中 | 中 | 高 | 极高 |
| 编译检查 | 基础 | 增强 | 完善 | 完善 |
| GC复杂度 | 中 | 中 | 低 | 极低 |

## v1.3 的主要改进

基于 v1.2，v1.3 主要改进：

1. ✅ **完善 ERROR 块机制** - 明确延迟声明语义和执行流程
2. ✅ **新增 Lambda 表达式** - 支持高阶函数，消除循环
3. ✅ **新增管道运算符** - `|>` 支持链式调用
4. ✅ **新增数组构造函数** - `Array()`、`Range()`
5. ✅ **明确引用语义** - 时间序列函数不复制数据
6. ✅ **完善内置变量** - 统一命名规范（`_args_names`）
7. ✅ **强化作用域规则** - Lambda 参数不能遮蔽外部变量
8. ✅ **明确并发安全模型** - 数据脚本为纯函数，包脚本顺序执行
9. ✅ **新增 elif 关键字** - 多条件分支更简洁
10. ✅ **支持链式比较** - `0 < x < 10` 等价于 `(0 < x) and (x < 10)`
11. ✅ **支持默认参数** - 函数定义可指定默认值，简化调用

## 包管理

作为领域专用语言，DPLang 不需要复杂的包管理系统。包的加载和依赖由**解释器外部编排**。

### 包加载顺序

```
解释器初始化：
1. 加载系统包（TA技术分析包等）
2. 按顺序加载用户包
3. 执行包级变量初始化
4. 构建函数注册表

数据流处理：
1. 加载数据处理脚本
2. 验证类型和依赖
3. 开始数据流处理
```

### 包使用示例

```DPLang
# 解释器配置（外部）
packages:
  - system/ta       # 系统技术分析包
  - user/indicators # 用户指标包
  - user/utils      # 用户工具包

# 数据脚本自动可访问所有已加载的包
-- INPUT code:string, close:number --
-- OUTPUT code:string, signal:string --

# 使用系统包
ma5 = MA(close, 5)  # 来自 system/ta

# 使用用户包
信号 = indicators.双均线信号(close, 5, 10)
结果 = utils.计算涨跌幅(open, close)

return [code, 信号]
```

## 工具链支持（规划）

- **LSP** - 语法高亮、自动补全、错误提示、跳转定义、Lambda 重构
- **格式化工具** - 统一代码风格，管道链自动换行
- **Linter** - 作用域检查、变量遮蔽检测、私有成员访问检查、Lambda 规范检查
- **类型检查器** - 独立的静态类型验证工具
- **流程图生成** - 可视化脚本逻辑，包括 Lambda 调用链
- **REPL** - 交互式开发环境，支持 Lambda 表达式测试
- **包管理器** - 包的发布和依赖管理（解释器编排）
- **调试器** - 断点、变量查看、包状态监控、Lambda 执行跟踪
- **性能分析器** - 识别热点函数、内存分配分析、Lambda 性能优化建议
